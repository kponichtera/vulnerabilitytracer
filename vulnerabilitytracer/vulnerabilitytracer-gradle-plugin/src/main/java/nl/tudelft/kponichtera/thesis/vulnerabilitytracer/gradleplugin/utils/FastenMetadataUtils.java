package nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.utils;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.experimental.UtilityClass;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.dto.CallableDTO;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.dto.VulnerabilityDTO;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.enums.Severity;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.exceptions.MalformedCallableDataException;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.exceptions.MalformedFastenUriException;

import java.util.Set;
import java.util.regex.Pattern;

@UtilityClass
public class FastenMetadataUtils {

    private static final Pattern FULL_FASTEN_URI_PATTERN = Pattern.compile("fasten://(.+)/(?<package>.+)/(.+)");
    private static final Pattern SHORT_FASTEN_URI_PATTERN = Pattern.compile("/(?<package>.+)/(.+)");
    private static final Pattern CALLABLE_NAME_PATTERN = Pattern.compile("(?<className>.+)::(?<methodName>.+)");

    public static String extractPackage(String fastenUri) throws MalformedFastenUriException {
        var matcher = SHORT_FASTEN_URI_PATTERN.matcher(fastenUri);
        if (matcher.matches()) {
            return matcher.group("package");
        }

        matcher = FULL_FASTEN_URI_PATTERN.matcher(fastenUri);
        if (matcher.matches()) {
            return matcher.group("package");
        }

        throw new MalformedFastenUriException(fastenUri);
    }

    public static ClassAndMethodName extractClassAndMethodName(CallableDTO callableDTO) throws MalformedCallableDataException {
        var metadata = callableDTO.getMetadata();
        if (metadata == null) {
            throw new MalformedCallableDataException("Callable has no metadata: " + callableDTO);
        }

        var qualityInfo = metadata.getQuality();
        if (qualityInfo == null) {
            throw new MalformedCallableDataException("Callable has no quality information: " + callableDTO);
        }

        var callableName = qualityInfo.getCallableName();
        if (callableName == null) {
            throw new MalformedCallableDataException("Callable has no callable name: " + callableDTO);
        }

        var matcher = CALLABLE_NAME_PATTERN.matcher(callableName);
        if (!matcher.matches()) {
            throw new MalformedCallableDataException("Callable has malformed name: " + callableDTO);
        }

        var className = matcher.group("className").replaceAll("::", ".");
        var methodName = matcher.group("methodName");

        return new ClassAndMethodName(className, methodName);
    }

    public static Set<String> extractVulnerabilityIds(CallableDTO callableDTO) throws MalformedCallableDataException {
        var metadata = callableDTO.getMetadata();
        if (metadata == null) {
            throw new MalformedCallableDataException("Callable has no metadata: " + callableDTO);
        }

        var vulnerabilities = metadata.getVulnerabilities();
        if (vulnerabilities == null || vulnerabilities.isEmpty()) {
            throw new MalformedCallableDataException("Callable has no vulnerabilities: " + callableDTO);
        }

        return callableDTO.getMetadata().getVulnerabilities().keySet();
    }

    public static Severity determineHighestSeverity(CallableDTO callableDTO) throws MalformedCallableDataException {
        var metadata = callableDTO.getMetadata();
        if (metadata == null) {
            throw new MalformedCallableDataException("Callable has no metadata: " + callableDTO);
        }

        var vulnerabilities = metadata.getVulnerabilities();
        if (vulnerabilities == null || vulnerabilities.isEmpty()) {
            throw new MalformedCallableDataException("Callable has no vulnerabilities: " + callableDTO);
        }

        return vulnerabilities.values()
                .stream()
                .map(VulnerabilityDTO::getSeverity)
                .max(Enum::compareTo)
                .orElse(Severity.UNDEFINED);
    }


    @Data
    @AllArgsConstructor
    public static final class ClassAndMethodName {

        String className;
        String methodName;

    }

}
