package nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JavaType;
import lombok.SneakyThrows;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.dto.CallableDTO;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.dto.SimpleVulnerabilityDTO;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.utils.FastenApiMapperUtils;

import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executors;

public class FastenApiService {

    private String apiUrl;
    private HttpClient client;

    public FastenApiService(String apiUrl, int executorThreadCount) {
        this.apiUrl = apiUrl;
        this.client = HttpClient.newBuilder()
                .executor(Executors.newFixedThreadPool(executorThreadCount))
                .build();
    }

    public CompletableFuture<HttpResponse<Void>> getPackageWithoutBody(String groupName,
                                                                       String artifactName,
                                                                       String version) {
        var request = HttpRequest.newBuilder(buildApiUri("api/mvn/packages/%s:%s/%s", groupName, artifactName, version))
                .GET()
                .build();

        return this.client.sendAsync(request, HttpResponse.BodyHandlers.discarding());
    }

    public CompletableFuture<List<SimpleVulnerabilityDTO>> getSimpleVulnerabilities(String groupName,
                                                                                    String artifactName,
                                                                                    String version) {
        var request = HttpRequest.newBuilder(buildApiUri("api/mvn/packages/%s:%s/%s/vulnerabilities?attributes=external_id", groupName, artifactName, version))
                .GET()
                .build();

        return sendAsyncAndDeserialize(request, FastenApiMapperUtils.getTypeFactory().constructCollectionType(List.class, SimpleVulnerabilityDTO.class));
    }

    /**
     * @param vulnerabilityExternalId
     * @return The map of callable ID to the (full) FASTEN URI
     */
    public CompletableFuture<Map<Long, String>> getVulnerabilityCallables(String vulnerabilityExternalId) {
        var request = HttpRequest.newBuilder(buildApiUri("api/mvn/vulnerabilities/%s/callables", vulnerabilityExternalId))
                .GET()
                .build();

        return sendAsyncAndDeserialize(request, FastenApiMapperUtils.getTypeFactory().constructMapType(Map.class, Long.class, String.class));
    }

    @SneakyThrows(JsonProcessingException.class)
    public CompletableFuture<Map<Long, CallableDTO>> getCallables(List<Long> callableIds) {
        String callableIdsBody = FastenApiMapperUtils.getMapper().writeValueAsString(callableIds);

        var request = HttpRequest.newBuilder(buildApiUri("api/mvn/callables"))
                .header("Content-Type", "application/json")
                .POST(HttpRequest.BodyPublishers.ofString(callableIdsBody))
                .build();

        return sendAsyncAndDeserialize(request, FastenApiMapperUtils.getTypeFactory().constructMapType(Map.class, Long.class, CallableDTO.class));
    }

    @SneakyThrows
    private URI buildApiUri(String pathFormat, String... args) {
        return new URI(String.format(this.apiUrl + "/" + pathFormat, (Object[]) args));
    }

    private <T> CompletableFuture<T> sendAsyncAndDeserialize(HttpRequest request, JavaType responseJavaType) {
        return this.client.sendAsync(request, HttpResponse.BodyHandlers.ofInputStream())
                .thenApply(response -> {
                    try {
                        return FastenApiMapperUtils.getMapper().readValue(response.body(), responseJavaType);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                });
    }
}
