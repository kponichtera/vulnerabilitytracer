package nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.service;

import com.fasterxml.jackson.core.exc.StreamReadException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DatabindException;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.dto.VulnerabilityDTO;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.exceptions.CacheCorruptedException;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.utils.FastenApiMapperUtils;
import org.slf4j.Logger;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;

public class CacheService {

    public static final String CACHE_DIRECTORY = "vulnerabilityTracerCache";

    public static final String VULNERABILITIES_FILENAME = "vulnerabilities.json";

    private final Path cacheDirPath;
    private final Logger log;

    public CacheService(File cacheRootDir, Logger log) {
        this.cacheDirPath = Path.of(cacheRootDir.getAbsolutePath(), CACHE_DIRECTORY);
        this.log = log;
    }

    public void ensureCacheDir() throws IOException {
        log.debug("Ensuring that cache directory exists ({})", cacheDirPath.toAbsolutePath());
        Files.createDirectories(cacheDirPath);
    }

    public File saveToCache(String packageName, String artifactName, String packageVersion,
                            List<VulnerabilityDTO> vulnerabilities) throws IOException {
        var cacheDirectory = createArtifactCacheDirectory(packageName, artifactName, packageVersion);
        var cacheFile = new File(cacheDirectory.toFile(), VULNERABILITIES_FILENAME);

        serializeAndWrite(cacheFile, vulnerabilities);
        return cacheFile;
    }

    public Optional<List<VulnerabilityDTO>> getVulnerabilitiesFromCache(String packageName, String artifactName, String packageVersion)
            throws IOException, CacheCorruptedException {
        var cacheDirectory = getArtifactCacheDirectory(packageName, artifactName, packageVersion);
        var cacheFile = new File(cacheDirectory.toFile(), VULNERABILITIES_FILENAME);

        return readAndDeserialize(cacheFile);
    }

    public void pruneCache() throws IOException {
        if (!cacheDirPath.toFile().exists()) {
            return;
        }

        var files = Files.walk(cacheDirPath)
                .sorted(Comparator.reverseOrder())
                .map(Path::toFile);

        if (log.isTraceEnabled()) {
            files.forEach(file -> {
                log.trace("Purging cache ({})", file.getAbsolutePath());
                file.delete();
            });
        } else {
            files.forEach(File::delete);
        }

        files.close();
    }

    private Path getArtifactCacheDirectory(String packageName, String artifactName, String packageVersion) {
        return Path.of(cacheDirPath.toString(), packageName, artifactName, packageVersion);
    }

    private Path createArtifactCacheDirectory(String packageName, String artifactName, String packageVersion) throws IOException {
        var cacheDirHierarchy = getArtifactCacheDirectory(packageName, artifactName, packageVersion);
        Files.createDirectories(cacheDirHierarchy);
        return cacheDirHierarchy;
    }

    private <T> void serializeAndWrite(File cacheFile, T value) throws IOException {
        log.trace("Saving to cache ({})", cacheFile.getAbsolutePath());
        FastenApiMapperUtils.getMapper().writeValue(cacheFile, value);
    }

    private <T> Optional<T> readAndDeserialize(File cacheFile) throws IOException, CacheCorruptedException {
        if (!cacheFile.exists()) {
            log.trace("Cache miss ({})", cacheFile.getAbsolutePath());
            return Optional.empty();
        }

        T cachedValue;
        try {
            log.trace("Reading from cache ({})", cacheFile.getAbsolutePath());
            cachedValue = FastenApiMapperUtils.getMapper().readValue(cacheFile, new TypeReference<T>() {
            });
        } catch (StreamReadException | DatabindException e) {
            throw new CacheCorruptedException(cacheFile, e);
        }
        return Optional.of(cachedValue);
    }

}
