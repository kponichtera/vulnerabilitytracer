package nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.tasks;

import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.dto.CallableDTO;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.dto.SimpleVulnerabilityDTO;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.exceptions.CacheCorruptedException;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.extensions.VulnerabilityTracerExtension;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.service.CacheService;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.service.DependencyService;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.service.FastenApiService;
import org.gradle.api.DefaultTask;
import org.gradle.api.GradleException;
import org.gradle.api.artifacts.ModuleVersionIdentifier;
import org.gradle.api.logging.Logger;
import org.gradle.api.tasks.TaskAction;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicInteger;

public class GenerateReport extends DefaultTask {

    private Logger logger;

    public GenerateReport() {
        setGroup("vulnerability tracer");
        setDescription("Generate report from dependency vulnerabilities, fetched from the FASTEN API");
        this.logger = getProject().getLogger();
    }

    @TaskAction
    public void runTask() throws IOException, InterruptedException {
        var extension = getProject().getExtensions().getByType(VulnerabilityTracerExtension.class);

        // Resolve dependencies and get their actual versions
        var cacheService = new CacheService(getProject().getGradle().getGradleUserHomeDir(), this.logger);
        var dependencyService = new DependencyService(getProject().getLogger());
        var dependencyVersions = dependencyService.getProjectDependencies(getProject());

        // TODO: Collect vulnerable callables for the project
        var apiService = new FastenApiService(extension.fastenApiUrl, extension.threadCount);
        Set<CallableDTO> callables;
        try {
            callables = collectVulnerableCallables(apiService, cacheService, dependencyVersions);
        } catch (CacheCorruptedException e) {
            throw new GradleException("Local vulnerability cache is corrupted", e);
        }

        // TODO: Prepare for saving

        // TODO: Save to file
    }

    private Set<CallableDTO> collectVulnerableCallables(FastenApiService apiService,
                                                        CacheService cacheService,
                                                        Set<ModuleVersionIdentifier> dependencyVersions)
            throws CacheCorruptedException, IOException, InterruptedException {

//        var cachedVulnerabilities = Collections.synchronizedSet(new HashSet<VulnerabilityDTO>());
//        var vulnerabilitiesToCache = new ConcurrentHashMap<ModuleVersionIdentifier, List<VulnerabilityDTO>>();

        // Collect vulnerabilities of all the packages in the project
        var collectedVulnerabilities = Collections.synchronizedSet(new HashSet<SimpleVulnerabilityDTO>());

        var vulnerabilitySuccessCount = new AtomicInteger();
        var vulnerabilityErrorCount = new AtomicInteger();
        var vulnerabilityLatch = new CountDownLatch(dependencyVersions.size());

        for (var version : dependencyVersions) {
            var groupName = version.getGroup();
            var artifactName = version.getName();
            var artifactVersion = version.getVersion();

            // TODO: Use cache first
//            var cachedVulnerability = cacheService.getVulnerabilitiesFromCache(groupName, artifactName, artifactVersion);
//            if (cachedVulnerability.isPresent()) {
//                cachedVulnerabilities.addAll(cachedVulnerability.get());
//            } else {
//                            apiService.getVulnerabilities(groupName, artifactName, artifactVersion)
//                    .thenApplyAsync(vulnerabilities -> vulnerabilitiesToCache.put(version, vulnerabilities));
//            }

//            apiService.getVulnerabilities(groupName, artifactName, artifactVersion)
//                    .thenApply(responseVulnerabilities -> {
//                        var callables = Collections.synchronizedSet(new HashSet<CallableDTO>());
//                        for (var vulnerability : vulnerabilities) {
//                            apiService.getVulnerabilityCallables(vulnerability.externalId())
//                                    .then(vulnerableCallables -> {
//                                        apiService.getCallables(vulnerableCallables.stream()
//                                                .map(
//                                                        VulnerabilityCallableDTO::callableId)
//                                                .toList()
//                                        );
//                                    });
//
//                        }
//
//                    });

            apiService.getSimpleVulnerabilities(groupName, artifactName, artifactVersion)
                    .thenAccept(responseVulnerabilities -> {
                        collectedVulnerabilities.addAll(responseVulnerabilities);
                        vulnerabilitySuccessCount.getAndIncrement();
                        vulnerabilityLatch.countDown();
                    })
                    .exceptionally(exception -> {
                        logger.error("Error occurred when making FASTEN API calls to fetch package vulnerabilities", exception);
                        vulnerabilityErrorCount.getAndIncrement();
                        vulnerabilityLatch.countDown();
                        return null;
                    });

        }

        logger.debug("Waiting for all vulnerabilities to be collected");
        vulnerabilityLatch.await();

        if (vulnerabilityErrorCount.get() == 0) {
            logger.quiet("{} vulnerabilities collected from {} dependencies",
                    collectedVulnerabilities.size(), dependencyVersions.size());
        } else {
            logger.warn("{} errors occurred, {}/{} vulnerabilities collected",
                    vulnerabilityErrorCount.get(), vulnerabilitySuccessCount.get(), dependencyVersions.size());
        }

        // TODO: cache the collected vulnerabilities
//        for (var vulnerability : vulnerabilitiesToCache.entrySet()) {
//            var groupName = vulnerability.getKey().getGroup();
//            var artifactName = vulnerability.getKey().getName();
//            var artifactVersion = vulnerability.getKey().getVersion();
//
//            cacheService.saveToCache(groupName, artifactName, artifactVersion, vulnerability.getValue());
//        }

        // Collect the callables to the vulnerabilities

        var callablesSuccessCount = new AtomicInteger();
        var callablesErrorCount = new AtomicInteger();
        var callableLatch = new CountDownLatch(collectedVulnerabilities.size());

        var collectedCallables = Collections.synchronizedSet(new HashSet<CallableDTO>());

        for (var vulnerability : collectedVulnerabilities) {
            apiService.getVulnerabilityCallables(vulnerability.getExternalId())
                    .thenApply(longStringMap -> new ArrayList<>(longStringMap.keySet()))
                    .thenCompose(apiService::getCallables)
                    .thenAccept(longCallableMap -> {
                        collectedCallables.addAll(longCallableMap.values());
                        callablesSuccessCount.getAndIncrement();
                        callableLatch.countDown();
                    })
                    .exceptionally(exception -> {
                        logger.error("Error occurred when making FASTEN API calls for vulnerability callables", exception);
                        callablesErrorCount.getAndIncrement();
                        callableLatch.countDown();
                        return null;
                    });
        }

        logger.debug("Waiting for all callables to be collected");
        callableLatch.await();

        if (callablesErrorCount.get() == 0) {
            logger.lifecycle("{} callables collected for {} vulnerabilities in {} dependencies",
                    collectedCallables.size(), collectedVulnerabilities.size(), dependencyVersions.size());
        } else {
            logger.lifecycle("{} errors occurred, {} callables collected for {}/{} vulnerabilities",
                    callablesErrorCount.get(), collectedCallables.size(), callablesSuccessCount.get(), collectedVulnerabilities.size());
        }

        return collectedCallables;
    }

}
