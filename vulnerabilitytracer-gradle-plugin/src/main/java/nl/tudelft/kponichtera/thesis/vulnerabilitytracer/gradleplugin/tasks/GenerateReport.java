package nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.tasks;

import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.dto.CallableDTO;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.exceptions.CacheCorruptedException;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.extensions.VulnerabilityTracerExtension;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.service.CacheService;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.service.DependencyService;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.service.FastenApiService;
import org.gradle.api.DefaultTask;
import org.gradle.api.artifacts.ModuleVersionIdentifier;
import org.gradle.api.logging.Logger;
import org.gradle.api.tasks.TaskAction;

import java.io.IOException;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CountDownLatch;

public class GenerateReport extends DefaultTask {

    private Logger logger;

    public GenerateReport() {
        setGroup("vulnerability tracer");
        setDescription("Generate report from dependency vulnerabilities, fetched from the FASTEN API");
        this.logger = getProject().getLogger();
    }

    @TaskAction
    public void runTask() throws IOException, InterruptedException {
        var extension = getProject().getExtensions().getByType(VulnerabilityTracerExtension.class);

        // Resolve dependencies and get their actual versions
        var cacheService = new CacheService(getProject().getGradle().getGradleUserHomeDir(), this.logger);
        var dependencyService = new DependencyService(getProject().getLogger());
        var dependencyVersions = dependencyService.getProjectDependencies(getProject());

        // TODO: Collect vulnerabilities for the project
//        var apiService = new FastenApiService(extension.fastenApiUrl, extension.threadCount);
//        List<VulnerabilityDTO> vulnerabilities;
//        try {
//            vulnerabilities = collectVulnerabilities(apiService, cacheService, dependencyVersions);
//        } catch (CacheCorruptedException e) {
//            throw new GradleException("Local vulnerability cache is corrupted", e);
//        }

        // TODO: Prepare for saving

        // TODO: Save to file
    }

    private List<CallableDTO> collectVulnerableCallables(FastenApiService apiService,
                                                         CacheService cacheService,
                                                         Set<ModuleVersionIdentifier> dependencyVersions) throws CacheCorruptedException, IOException, InterruptedException {

//        var cachedVulnerabilities = Collections.synchronizedSet(new HashSet<VulnerabilityDTO>());
//        var vulnerabilitiesToCache = new ConcurrentHashMap<ModuleVersionIdentifier, List<VulnerabilityDTO>>();

//        var futures = new ArrayList<CompletableFuture<Map<CallableDTO>>>();

        var latch = new CountDownLatch(dependencyVersions.size());


        for (var version : dependencyVersions) {
            var groupName = version.getGroup();
            var artifactName = version.getName();
            var artifactVersion = version.getVersion();

            // TODO: Use cache first

//            var cachedVulnerability = cacheService.getVulnerabilitiesFromCache(groupName, artifactName, artifactVersion);
//            if (cachedVulnerability.isPresent()) {
//                cachedVulnerabilities.addAll(cachedVulnerability.get());
//            } else {
//                apiService.getVulnerabilities(groupName, artifactName, artifactVersion)
//                        .thenApplyAsync(vulnerabilities -> vulnerabilitiesToCache.put(version, vulnerabilities));
//
//            }
        }

        latch.await();
//
//        for (var vulnerability : vulnerabilitiesToCache.entrySet()) {
//            var groupName = vulnerability.getKey().getGroup();
//            var artifactName = vulnerability.getKey().getName();
//            var artifactVersion = vulnerability.getKey().getVersion();
//
//            cacheService.saveToCache(groupName, artifactName, artifactVersion, vulnerability.getValue());
//        }

        return null;
    }

    private record PackageVersion(
            String groupName,
            String artifactName,
            String artifactVersion
    ) {
    }

}
