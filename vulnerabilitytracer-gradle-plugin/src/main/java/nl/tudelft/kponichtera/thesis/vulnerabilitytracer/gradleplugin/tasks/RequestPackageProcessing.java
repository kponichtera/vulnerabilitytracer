package nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.tasks;

import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.extensions.VulnerabilityTracerExtension;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.service.DependencyService;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.service.FastenApiService;
import org.gradle.api.DefaultTask;
import org.gradle.api.logging.Logger;
import org.gradle.api.tasks.TaskAction;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicInteger;

public class RequestPackageProcessing extends DefaultTask {

    private Logger logger;

    public RequestPackageProcessing() {
        setGroup("vulnerability tracer");
        setDescription("Request FASTEN API to process project's dependencies");
        this.logger = getProject().getLogger();
    }

    @TaskAction
    public void runTask() throws InterruptedException {
        var extension = getProject().getExtensions().getByType(VulnerabilityTracerExtension.class);

        // Resolve dependencies and get their actual versions
        var dependencyService = new DependencyService(getProject().getLogger());
        var dependencyVersions = dependencyService.getProjectDependencies(getProject());

        var apiService = new FastenApiService(extension.fastenApiUrl, extension.threadCount);

        AtomicInteger readyCount = new AtomicInteger();
        AtomicInteger queuedCount = new AtomicInteger();
        AtomicInteger errorCount = new AtomicInteger();

        var latch = new CountDownLatch(dependencyVersions.size());
        for (var version : dependencyVersions) {
            var groupName = version.getGroup();
            var artifactName = version.getName();
            var artifactVersion = version.getVersion();

            logger.debug("Requesting for package {}:{}:{}", groupName, artifactName, artifactVersion);
            apiService.getPackageWithoutBody(groupName, artifactName, artifactVersion)
                    .thenAccept(response -> {
                        if (response.statusCode() == 200) {
                            logger.quiet("Processed: {}:{}:{}", groupName, artifactName, artifactVersion);
                            readyCount.getAndIncrement();
                        } else if (response.statusCode() == 201) {
                            logger.quiet("Queued: {}:{}:{}", groupName, artifactName, artifactVersion);
                            queuedCount.getAndIncrement();
                        } else {
                            logger.error("Unexpected response from the FASTEN API. Code: {}", response.statusCode());
                            errorCount.getAndIncrement();
                        }
                        latch.countDown();
                    });
        }

        latch.await();

        if (errorCount.get() > 0) {
            logger.error("There were {} errors when requesting package processing from FASTEN API", errorCount.get());
        }
        if (readyCount.get() > 0) {
            logger.lifecycle("{} packages were already processed", readyCount.get());
        } else if (readyCount.get() == dependencyVersions.size()) {
            logger.lifecycle("All packages were processed");
        }
        if (queuedCount.get() > 0) {
            logger.lifecycle("{} packages were added to the processing queue", queuedCount.get());
            logger.lifecycle("Wait for the FASTEN to process all the packages before proceeding with the analysis.");
        }
    }

}
