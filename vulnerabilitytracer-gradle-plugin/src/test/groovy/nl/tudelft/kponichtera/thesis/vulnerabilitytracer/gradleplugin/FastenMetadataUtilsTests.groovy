package nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin

import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.dto.CallableDTO
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.dto.VulnerabilityDTO
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.enums.Severity
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.exceptions.MalformedCallableDataException
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.exceptions.MalformedFastenUriException
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.gradleplugin.utils.FastenMetadataUtils
import spock.lang.Specification

class FastenMetadataUtilsTests extends Specification {

    def "extracting package from full FASTEN URI works"() {
        when:
        def extractedPackageName = FastenMetadataUtils.extractPackage(fastenUri)

        then:
        extractedPackageName == packageName

        where:
        packageName    | fastenUri
        "org.dom4j.io" | "fasten://mvn!dom4j:dom4j\$1.6.1/org.dom4j.io/SAXReader.isValidating()%2Fjava.lang%2FBooleanType"
    }

    def "extracting package from simple FASTEN URI works"() {
        when:
        def extractedPackageName = FastenMetadataUtils.extractPackage(fastenUri)

        then:
        extractedPackageName == packageName

        where:
        packageName                                | fastenUri
        "org.springframework.util"                 | "/org.springframework.util/ConcurrentReferenceHashMap.%3Cinit%3E()%2Fjava.lang%2FVoidType"
        "org.springframework.core.convert.support" | "/org.springframework.core.convert.support/ConfigurableConversionService.addConverter(%2Forg.springframework.core.convert.converter%2FConverter)%2Fjava.lang%2FVoidType"
    }

    def "extracting package from malformed FASTEN URI throws an exception"() {
        when:
        def extractedPackageName = FastenMetadataUtils.extractPackage(fastenUri)

        then:
        thrown MalformedFastenUriException

        where:
        fastenUri                                                                                                                                                                       | _
        "/org.springframework.utilConcurrentReferenceHashMap.%3Cinit%3E()%2Fjava.lang%2FVoidType"                                                                                       | _
        "org.springframework.core.convert.support/ConfigurableConversionService.addConverter(%2Forg.springframework.core.convert.converter%2FConverter)%2Fjava.lang%2FVoidType"         | _
        "fasten:/org.springframework.core.convert.support/ConfigurableConversionService.addConverter(%2Forg.springframework.core.convert.converter%2FConverter)%2Fjava.lang%2FVoidType" | _
    }

    def "extracting class and method names from callable DTO works"() {
        given:
        def callableDTO = makeValidCallableDTO(callableName)

        when:
        def result = FastenMetadataUtils.extractClassAndMethodName(callableDTO)

        then:
        result.className == expectedClassName
        result.methodName == expectedMethodName

        where:
        callableName                                       | expectedClassName                  | expectedMethodName
        "TokenFilter::addContainsString"                   | "TokenFilter"                      | "addContainsString"
        "TokenFilter::_addContainsString"                  | "TokenFilter"                      | "_addContainsString"
        "FixCrLfFilter::SimpleFilterReader::markSupported" | "FixCrLfFilter.SimpleFilterReader" | "markSupported"
    }

    def "extracting class and method names from malformed callable DTO throws an exception"() {
        given:
        def callableDTO = makeValidCallableDTO(callableName)

        when:
        FastenMetadataUtils.extractClassAndMethodName(callableDTO)

        then:
        thrown MalformedCallableDataException

        where:
        callableName                                   | _
        "TokenFilter.addContainsString"                | _
        "TokenFilter_addContainsString"                | _
        "FixCrLfFilterSimpleFilterReadermarkSupported" | _
        ""                                             | _
    }

    def "extracting class and method names from callable DTO with missing fields throws an exception"() {
        given:
        def callableDTO = makeValidCallableDTO("TokenFilter::addContainsString")

        and:
        callableDTO.metadata.quality = null

        when:
        FastenMetadataUtils.extractClassAndMethodName(callableDTO)

        then:
        thrown MalformedCallableDataException
    }

    def "extracting class and method names from callable DTO with missing fields throws an exception"() {
        given:
        def callableDTO = makeValidCallableDTO("TokenFilter::addContainsString")

        and:
        callableDTO.metadata.quality = null

        when:
        FastenMetadataUtils.extractClassAndMethodName(callableDTO)

        then:
        thrown MalformedCallableDataException
    }

    def "extracting class and method names from callable DTO with missing fields throws an exception"() {
        given:
        def callableDTO = makeValidCallableDTO("TokenFilter::addContainsString")

        and:
        callableDTO.metadata.quality = null

        when:
        FastenMetadataUtils.extractClassAndMethodName(callableDTO)

        then:
        thrown MalformedCallableDataException
    }

    def "extracting vulnerabilities from the callable DTO works"() {
        given:
        def callableDTO = makeValidCallableDTO("TokenFilter::addContainsString")

        when:
        def vulnerabilityIds = FastenMetadataUtils.extractVulnerabilityIds(callableDTO)

        then:
        !vulnerabilityIds.empty
    }


    def "extracting vulnerabilities from malformed callable DTO throws an exception"() {
        given:
        def callableDTO = makeValidCallableDTO("TokenFilter::addContainsString")

        and:
        callableDTO.metadata.vulnerabilities = new HashMap<>()

        when:
        FastenMetadataUtils.extractVulnerabilityIds(callableDTO)

        then:
        thrown MalformedCallableDataException
    }

    def "determining overall highest severity for vulnerabilities works"() {
        given:
        def callableDTO = makeValidCallableDTO("TokenFilter::addContainsString")

        when:
        var maxSeverity = FastenMetadataUtils.determineHighestSeverity(callableDTO)

        then:
        maxSeverity == Severity.CRITICAL
    }

    private def makeValidCallableDTO(String callableName) {
        def callableDTO = new CallableDTO()
        callableDTO.fastenUri = "/org.LatencyUtils/TimeServices.access\$200()%2Fjava.lang%2FObject"
        callableDTO.metadata = new CallableDTO.CallableMetadataDTO()
        callableDTO.metadata.vulnerabilities = makeValidVulnerabilityMap()
        callableDTO.metadata.quality = new CallableDTO.QualityDTO()
        callableDTO.metadata.quality.callableName = callableName
        return callableDTO
    }

    private def makeValidVulnerabilityMap() {
        def map = new HashMap<String, VulnerabilityDTO>()
        map.put("CVE-2013-4152", new VulnerabilityDTO("CVE-2013-4152", Severity.LOW))
        map.put("CVE-2009-2625", new VulnerabilityDTO("CVE-2009-2625", Severity.HIGH))
        map.put("GHSA-w736-hf9p-qqh3", new VulnerabilityDTO("GHSA-w736-hf9p-qqh3", Severity.CRITICAL))
        map.put("CVE-2017-15712", new VulnerabilityDTO("CVE-2017-15712", Severity.MODERATE))
        return map
    }

}
