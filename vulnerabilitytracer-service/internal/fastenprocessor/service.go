package fastenprocessor

import (
	"context"
	"fmt"
	"sync"

	"vulnerabilitytracer/pkg/callables"
	"vulnerabilitytracer/pkg/maven"

	"github.com/sirupsen/logrus"

	"vulnerabilitytracer/internal/runtime"
)

func Run(ctx context.Context, runtimeCtx runtime.Context) error {
	_, err := getProcessedDependencies(ctx, runtimeCtx)
	if err != nil {
		return fmt.Errorf("error when getting processed dependencies: %w", err)
	}

	return nil
}

type dependencyToProcess struct {
	id          int64
	coordinates maven.Coordinates
}

func getProcessedDependencies(ctx context.Context, runtimeCtx runtime.Context) ([]dependencyToProcess, error) {
	type processedDependency struct {
		id          int64
		coordinates maven.Coordinates
		status      callables.DependencyProcessingStatus
	}

	dependencies, err := runtimeCtx.DBQueries.GetUnprocessedFastenDependencies(ctx)
	if err != nil {
		return nil, fmt.Errorf("error when getting unprocessed dependencies: %w", err)
	}

	waitGroup := new(sync.WaitGroup)
	succChan := make(chan processedDependency)
	errChan := make(chan error)

	for _, d := range dependencies {
		dependencyID := d.ID
		coordinates := maven.Coordinates{
			GroupID:    d.GroupID,
			ArtifactID: d.ArtifactID,
			Version:    d.Version,
		}

		waitGroup.Add(1)

		go func() {
			defer waitGroup.Done()

			status, err := runtimeCtx.FastenCallableRepository.GetDependencyProcessingStatus(ctx, coordinates)
			if err != nil {
				errChan <- err
			} else {
				succChan <- processedDependency{
					id:          dependencyID,
					coordinates: coordinates,
					status:      status,
				}
			}
		}()
	}

	go func() {
		waitGroup.Wait()
		close(succChan)
		close(errChan)
	}()

	errorCount := 0
	succChanClosed := false
	errChanClosed := false

	processedDependencies := make([]dependencyToProcess, 0)
	unprocessedDependencyCount := 0

	for {
		select {
		case processedDep, ok := <-succChan:
			if !ok {
				succChanClosed = true
			} else {
				if processedDep.status == callables.Processed {
					processedDependencies = append(processedDependencies, dependencyToProcess{
						id:          processedDep.id,
						coordinates: processedDep.coordinates,
					})

					logrus.
						WithField("groupID", processedDep.coordinates.GroupID).
						WithField("artifactID", processedDep.coordinates.ArtifactID).
						WithField("version", processedDep.coordinates.Version).
						Info("ready to be processed")
				} else {
					logrus.
						WithField("groupID", processedDep.coordinates.GroupID).
						WithField("artifactID", processedDep.coordinates.ArtifactID).
						WithField("version", processedDep.coordinates.Version).
						Info("not ready to be processed")
					unprocessedDependencyCount++
				}
			}
		case err, ok := <-errChan:
			if !ok {
				errChanClosed = true
			} else {
				logrus.
					WithError(err).
					Error("error when getting dependency processing status")
				errorCount++
			}
		}
		if succChanClosed && errChanClosed {
			break
		}
	}

	logrus.
		WithField("processedCount", len(processedDependencies)).
		WithField("unprocessedCount", unprocessedDependencyCount).
		WithField("errorCount", errorCount).
		Info("fetched processing status of dependencies from FASTEN")

	return processedDependencies, nil
}
