package vulnerabilityupdaterprocessor

import (
	"context"
	"fmt"
	"time"

	"vulnerabilitytracer/pkg/service"

	"vulnerabilitytracer/db/generated/queries"
	"vulnerabilitytracer/internal/utils"
	"vulnerabilitytracer/pkg/maven"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/sirupsen/logrus"

	"vulnerabilitytracer/internal/processor"
	"vulnerabilitytracer/internal/runtime"
)

func Run(ctx context.Context, runtimeCtx runtime.Context) error {
	var config Config
	processor.ReadJobConfig(ctx, &config)

	// Get dependencies that have not been updated for long enough (changeable in the processor's config)
	dependenciesToUpdate, err := getDependenciesToUpdate(ctx, runtimeCtx, config)
	if err != nil {
		return fmt.Errorf("error when getting dependencies to update: %w", err)
	}

	if len(dependenciesToUpdate) == 0 {
		logrus.Info("no dependencies to update")
		return nil
	}

	logrus.
		WithField("count", len(dependenciesToUpdate)).
		Info("fetched dependencies to update")

	// Fetch the vulnerabilities and callables of the processed dependencies, and link them to the dependencies
	dependenciesWithVulnerabilities, err := service.UpdateVulnerabilitiesAndCallables(ctx, runtimeCtx, dependenciesToUpdate)
	if err != nil {
		return fmt.Errorf("error when updating vulnerabilities and callables: %w", err)
	}

	logrus.
		WithField("count", len(dependenciesWithVulnerabilities)).
		Info("updated vulnerabilities and callables")

	// TODO: Add the restart notifications for the (latest versions of) services that use the dependencies
	//  Or maybe add the notification logic to the UpdateVulnerabilitiesAndCallables?

	// Update the vulnerability update time of the processed dependencies
	dependencyIDs := utils.GetMapValues(dependenciesToUpdate)
	err = updateVulnerabilityUpdateTime(ctx, runtimeCtx, dependencyIDs)
	if err != nil {
		return fmt.Errorf("error when updating vulnerability update time: %w", err)
	}

	return nil
}

func getDependenciesToUpdate(ctx context.Context, runtimeCtx runtime.Context, config Config) (map[maven.Coordinates]int64, error) {
	dependencyUpdateThresholdTime := time.Now().Add(-config.DurationBeforeUpdate)

	dependencies, err := runtimeCtx.DBQueries.GetDependenciesToUpdate(ctx, queries.GetDependenciesToUpdateParams{
		VulnerabilityUpdateTime: pgtype.Timestamptz{
			Time:  dependencyUpdateThresholdTime,
			Valid: true,
		},
		Limit: config.DependencyBatchSize,
	})
	if err != nil {
		return nil, fmt.Errorf("error when getting dependencies from database: %w", err)
	}

	coordinatesIDMap := make(map[maven.Coordinates]int64)
	for _, d := range dependencies {
		coordinatesIDMap[maven.Coordinates{
			GroupID:    d.GroupID,
			ArtifactID: d.ArtifactID,
			Version:    d.Version,
		}] = d.ID
	}

	return coordinatesIDMap, nil
}

func updateVulnerabilityUpdateTime(ctx context.Context, runtimeCtx runtime.Context, dependencyIDs []int64) error {
	if err := runtimeCtx.DBQueries.UpdateVulnerabilityUpdateTime(ctx, dependencyIDs); err != nil {
		return fmt.Errorf("error when updating vulnerability update time in the database: %w", err)
	}

	logrus.
		WithField("count", len(dependencyIDs)).
		Info("updated vulnerability update time")

	return nil
}
