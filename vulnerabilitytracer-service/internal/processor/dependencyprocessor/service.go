package dependencyprocessor

import (
	"context"
	"fmt"
	"sync"

	"vulnerabilitytracer/internal/processor"
	"vulnerabilitytracer/internal/utils"
	"vulnerabilitytracer/pkg/callables"
	"vulnerabilitytracer/pkg/maven"
	"vulnerabilitytracer/pkg/service"

	"github.com/sirupsen/logrus"

	"vulnerabilitytracer/internal/runtime"
)

func Run(ctx context.Context, runtimeCtx runtime.Context) error {
	var config Config
	processor.ReadJobConfig(ctx, &config)

	// Get dependencies that have been processed by FASTEN
	processedDependencies, err := getProcessedDependencies(ctx, runtimeCtx)
	if err != nil {
		return fmt.Errorf("error when getting processed dependencies: %w", err)
	}

	if len(processedDependencies) == 0 {
		logrus.Info("no new processed dependencies")
		return nil
	}

	// Fetch the vulnerabilities and callables of the processed dependencies, and link them to the dependencies
	_, err = service.UpdateVulnerabilitiesAndCallables(ctx, runtimeCtx, processedDependencies)
	if err != nil {
		return fmt.Errorf("error when registering vulnerabilities and callables: %w", err)
	}

	// TODO: Add the restart notifications for the (latest versions of) services that use the dependencies
	//  Or maybe add the notification logic to the UpdateVulnerabilitiesAndCallables?

	// Mark the processed dependencies as processed in the database
	err = markDependenciesAsProcessed(ctx, runtimeCtx, processedDependencies)
	if err != nil {
		return fmt.Errorf("error when marking dependencies as processed: %w", err)
	}

	return nil
}

func markDependenciesAsProcessed(ctx context.Context, runtimeCtx runtime.Context, dependencyIDMap map[maven.Coordinates]int64) error {
	dependencyIDs := utils.GetMapValues(dependencyIDMap)

	if err := runtimeCtx.DBQueries.SetFastenDependenciesAsProcessed(ctx, dependencyIDs); err != nil {
		return fmt.Errorf("error when changing process status in the database: %w", err)
	}

	logrus.
		WithField("count", len(dependencyIDs)).
		Info("marked dependencies as processed")

	return nil
}

func getProcessedDependencies(ctx context.Context, runtimeCtx runtime.Context) (map[maven.Coordinates]int64, error) {
	type processedDependency struct {
		id          int64
		coordinates maven.Coordinates
		status      callables.DependencyProcessingStatus
	}

	dependencies, err := runtimeCtx.DBQueries.GetUnprocessedFastenDependencies(ctx)
	if err != nil {
		return nil, fmt.Errorf("error when getting unprocessed dependencies: %w", err)
	}

	waitGroup := new(sync.WaitGroup)
	succChan := make(chan processedDependency)
	errChan := make(chan error)

	for _, d := range dependencies {
		dependencyID := d.ID
		coordinates := maven.Coordinates{
			GroupID:    d.GroupID,
			ArtifactID: d.ArtifactID,
			Version:    d.Version,
		}

		waitGroup.Add(1)

		go func() {
			defer waitGroup.Done()

			status, err := runtimeCtx.FastenCallableRepository.GetDependencyProcessingStatus(ctx, coordinates)
			if err != nil {
				errChan <- err
			} else {
				succChan <- processedDependency{
					id:          dependencyID,
					coordinates: coordinates,
					status:      status,
				}
			}
		}()
	}

	go func() {
		waitGroup.Wait()
		close(succChan)
		close(errChan)
	}()

	errorCount := 0
	succChanClosed := false
	errChanClosed := false

	processedDependencies := make(map[maven.Coordinates]int64)
	unprocessedDependencyCount := 0

	for {
		select {
		case processedDep, ok := <-succChan:
			if !ok {
				succChanClosed = true
			} else {
				if processedDep.status == callables.Processed {
					processedDependencies[processedDep.coordinates] = processedDep.id

					logrus.
						WithField("groupID", processedDep.coordinates.GroupID).
						WithField("artifactID", processedDep.coordinates.ArtifactID).
						WithField("version", processedDep.coordinates.Version).
						Info("ready to be processed")
				} else {
					logrus.
						WithField("groupID", processedDep.coordinates.GroupID).
						WithField("artifactID", processedDep.coordinates.ArtifactID).
						WithField("version", processedDep.coordinates.Version).
						Info("not ready to be processed")
					unprocessedDependencyCount++
				}
			}
		case err, ok := <-errChan:
			if !ok {
				errChanClosed = true
			} else {
				logrus.
					WithError(err).
					Error("error when getting dependency processing status")
				errorCount++
			}
		}

		if succChanClosed && errChanClosed {
			break
		}
	}

	logrus.
		WithField("processedCount", len(processedDependencies)).
		WithField("unprocessedCount", unprocessedDependencyCount).
		WithField("errorCount", errorCount).
		Info("fetched processing status of dependencies from FASTEN")

	return processedDependencies, nil
}
