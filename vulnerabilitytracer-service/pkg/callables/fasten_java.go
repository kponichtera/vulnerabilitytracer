package callables

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"

	"vulnerabilitytracer-service/pkg/maven"
	"vulnerabilitytracer-service/pkg/vulnerabilities"

	"vulnerabilitytracer-service/api/generated/fastenapi"
	"vulnerabilitytracer-service/pkg/fasten"

	mapset "github.com/deckarep/golang-set/v2"
	"github.com/sirupsen/logrus"
	"golang.org/x/sync/semaphore"
)

var (
	ErrCallableIDIsNotInteger         = errors.New("callable ID is not a valid integer")
	ErrMissingCallableQualityMetadata = errors.New("missing callable quality metadata")
)

type FastenJavaCallableRepository struct {
	apiClient          *fastenapi.ClientWithResponses
	apiClientSemaphore *semaphore.Weighted
}

func useFastenApiClient[R interface{}](ctx context.Context, repository *FastenJavaCallableRepository,
	apiConsumeFunc func(*fastenapi.ClientWithResponses, chan<- R, chan<- error),
) (<-chan R, <-chan error, error) {
	err := repository.apiClientSemaphore.Acquire(ctx, 1)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to acquire FASTEN API semaphore: %w", err)
	}

	successChan := make(chan R)
	errorChan := make(chan error)

	go func() {
		defer repository.apiClientSemaphore.Release(1)
		apiConsumeFunc(repository.apiClient, successChan, errorChan)
	}()

	return successChan, errorChan, nil
}

func NewFastenJavaCallableRepository(apiClient *fastenapi.ClientWithResponses) *FastenJavaCallableRepository {
	return &FastenJavaCallableRepository{
		apiClient:          apiClient,
		apiClientSemaphore: semaphore.NewWeighted(10), // TODO: Get from config
	}
}

func (r *FastenJavaCallableRepository) getVulnerabilitiesForDependency(ctx context.Context, coordinates maven.Coordinates) ([]fastenapi.PackageVulnerability, error) {
	// Get vulnerabilities for the dependency
	vulnerabilitySuccChan, errChan, err := useFastenApiClient(ctx, r,
		func(apiClient *fastenapi.ClientWithResponses, succChan chan<- []fastenapi.PackageVulnerability, errChan chan<- error) {
			vulnerabilities, err := fasten.GetSimpleVulnerabilities(ctx, apiClient, coordinates.GroupID, coordinates.ArtifactID, coordinates.Version)
			if err != nil {
				errChan <- fmt.Errorf("error when getting vulnerabilities for dependency: %w", err)
			} else {
				succChan <- vulnerabilities
			}
			close(succChan)
			close(errChan)
		})
	if err != nil {
		return nil, fmt.Errorf("error when using FASTEN API client: %w", err)
	}

	var vulnerabilities []fastenapi.PackageVulnerability

	select {
	case err := <-errChan:
		return nil, fmt.Errorf("error in FASTEN API client goroutine: %w", err)
	case succ := <-vulnerabilitySuccChan:
		vulnerabilities = succ
	}

	logrus.
		WithField("artifactID", coordinates.ArtifactID).
		WithField("groupID", coordinates.GroupID).
		WithField("version", coordinates.Version).
		WithField("vulnerabilityCount", len(vulnerabilities)).
		Info("finished collecting vulnerabilities for dependency")

	return vulnerabilities, nil
}

type vulnerabilityCallables struct {
	FastenID          string
	Severity          vulnerabilities.Severity
	CallableFastenIDs []int
}

func getVulnerabilitySeverity(vulnerability fastenapi.PackageVulnerability) vulnerabilities.Severity {
	if vulnerability.Statement == nil {
		return vulnerabilities.SeverityUndefined
	}
	severityString, ok := vulnerability.Statement["severity"]
	if !ok {
		return vulnerabilities.SeverityUndefined
	}

	switch severityString {
	case "LOW":
		return vulnerabilities.SeverityLow
	case "MODERATE":
		return vulnerabilities.SeverityModerate
	case "MEDIUM":
		return vulnerabilities.SeverityMedium
	case "HIGH":
		return vulnerabilities.SeverityHigh
	case "CRITICAL":
		return vulnerabilities.SeverityCritical
	default:
		return vulnerabilities.SeverityUndefined
	}
}

// getCallableIdsForVulnerabilities returns the map of vulnerability external IDs to FASTEN callable IDs.
func (r *FastenJavaCallableRepository) getCallableIdsForVulnerabilities(ctx context.Context, vulnerabilities []fastenapi.PackageVulnerability) ([]vulnerabilityCallables, error) {
	waitGroup := new(sync.WaitGroup)
	globalSuccChan := make(chan vulnerabilityCallables)
	globalErrChan := make(chan error)

	for _, vulnerability := range vulnerabilities {
		vulnerabilityExternalID := vulnerability.ExternalId
		vulnerabilitySeverity := getVulnerabilitySeverity(vulnerability)

		waitGroup.Add(1)
		go func() {
			defer waitGroup.Done()

			succChan, errChan, err := useFastenApiClient(ctx, r,
				func(apiClient *fastenapi.ClientWithResponses, succChan chan<- map[string]string, errChan chan<- error) {
					callablesMap, err := fasten.GetVulnerabilityCallables(ctx, apiClient, vulnerabilityExternalID)
					if err != nil {
						errChan <- fmt.Errorf("error when getting callables for vulnerability: %w", err)
					} else {
						succChan <- callablesMap
					}
					close(succChan)
					close(errChan)
				})
			if err != nil {
				logrus.WithError(err).Error("error when using FASTEN API client")
				globalErrChan <- err
			} else {
				select {
				case err := <-errChan:
					logrus.WithError(err).Error("error in FASTEN API client goroutine")
					globalErrChan <- err
				case succ := <-succChan:
					logrus.Infof("finished collecting callables for vulnerability: %d", len(succ))
					callableIds := mapset.NewSet[int]()

					for key := range succ {
						callableID, err := strconv.Atoi(key)
						if err != nil {
							logrus.WithError(err).Error("error when converting callable ID to integer")
						} else {
							callableIds.Add(callableID)
						}
					}
					globalSuccChan <- vulnerabilityCallables{
						FastenID:          vulnerabilityExternalID,
						Severity:          vulnerabilitySeverity,
						CallableFastenIDs: callableIds.ToSlice(),
					}
				}
			}
		}()
	}

	go func() {
		waitGroup.Wait()
		close(globalSuccChan)
		close(globalErrChan)
	}()

	vulnerabilityCallables := make([]vulnerabilityCallables, 0)
	errorCount := 0
	globalSuccChanClosed := false
	globalErrChanClosed := false

	for {
		select {
		case succ, ok := <-globalSuccChan:
			if !ok {
				globalSuccChanClosed = true
			} else {
				vulnerabilityCallables = append(vulnerabilityCallables, succ)
			}
		case _, ok := <-globalErrChan:
			if !ok {
				globalErrChanClosed = true
			}
			errorCount++
		}

		if globalSuccChanClosed && globalErrChanClosed {
			break
		}
	}

	logrus.
		WithField("vulnerabilityCount", len(vulnerabilityCallables)).
		WithField("errorCount", errorCount).
		Info("finished collecting callable IDs")

	return vulnerabilityCallables, nil
}

type fastenJavaCallable struct {
	FastenID    int
	FastenURI   string
	PackageName string
	ClassName   string
	MethodName  string
}

func (r *FastenJavaCallableRepository) getCallables(ctx context.Context, callableIds []int) ([]fastenJavaCallable, error) {
	callablesSuccChan, errChan, err := useFastenApiClient(ctx, r,
		func(apiClient *fastenapi.ClientWithResponses, succChan chan<- map[string]fastenapi.Callable, errChan chan<- error) {
			callables, err := fasten.GetCallables(ctx, apiClient, callableIds)
			if err != nil {
				errChan <- fmt.Errorf("error when getting callables: %w", err)
			} else {
				succChan <- callables
			}
			close(succChan)
			close(errChan)
		})
	if err != nil {
		return nil, fmt.Errorf("error when using FASTEN API client: %w", err)
	}

	var callablesMap map[string]fastenapi.Callable

	select {
	case err := <-errChan:
		return nil, fmt.Errorf("error in FASTEN API client goroutine: %w", err)
	case succ := <-callablesSuccChan:
		callablesMap = succ
	}

	callables, parseErrors := parseFastenCallables(callablesMap)

	logrus.
		WithField("successCount", len(callables)).
		WithField("errorCount", len(parseErrors)).
		Info("finished parsing FASTEN callables")

	return callables, nil
}

func parseFastenCallables(callablesMap map[string]fastenapi.Callable) ([]fastenJavaCallable, []error) {
	callables := make([]fastenJavaCallable, 0)
	parseErrors := make([]error, 0)

	for callableID, callable := range callablesMap {
		callableIDInt, err := strconv.Atoi(callableID)
		if err != nil {
			logrus.
				WithField("callableID", callableID).
				WithError(err).
				Error("problem with converting callable ID to integer")

			parseErrors = append(parseErrors, ErrCallableIDIsNotInteger)
			continue
		}

		if callable.Metadata.Quality == nil {
			logrus.
				WithField("callableID", callableID).
				Warn("missing callable quality metadata")
			parseErrors = append(parseErrors, ErrMissingCallableQualityMetadata)
			continue
		}

		packageName, err := fasten.JavaPackageFromFastenURI(callable.FastenUri)
		if err != nil {
			logrus.
				WithField("callableID", callableID).
				WithError(err).
				Error("problem with parsing package name from FASTEN URI")

			parseErrors = append(parseErrors, err)
			continue
		}

		classAndMethodName, err := fasten.ClassAndMethodNameFromCallableName(callable.Metadata.Quality.CallableName)
		if err != nil {
			logrus.
				WithField("callableID", callableID).
				WithError(err)

			parseErrors = append(parseErrors, err)
			continue
		}

		callable := fastenJavaCallable{
			FastenID:    callableIDInt,
			FastenURI:   callable.FastenUri,
			PackageName: packageName,
			ClassName:   classAndMethodName.ClassName,
			MethodName:  classAndMethodName.MethodName,
		}

		callables = append(callables, callable)
	}

	return callables, parseErrors
}

func mapVulnerabilitiesToCallables(vulnerabilityCallablesList []vulnerabilityCallables, fastenJavaCallables []fastenJavaCallable) map[vulnerabilities.Vulnerability][]JavaCallable {
	vulnerabilityJavaCallableMap := make(map[vulnerabilities.Vulnerability][]JavaCallable)

	vulnerabilityCallablesMap := make(map[string]vulnerabilityCallables)
	for _, vulnerabilityCallable := range vulnerabilityCallablesList {
		vulnerabilityCallablesMap[vulnerabilityCallable.FastenID] = vulnerabilityCallable
		vulnerabilityJavaCallableMap[vulnerabilities.Vulnerability{
			ExternalID: vulnerabilityCallable.FastenID,
			Severity:   vulnerabilityCallable.Severity,
		}] = []JavaCallable{}
	}

	callablesMap := make(map[int]fastenJavaCallable)
	for _, fastenJavaCallable := range fastenJavaCallables {
		callablesMap[fastenJavaCallable.FastenID] = fastenJavaCallable
	}

	for vulnerability := range vulnerabilityJavaCallableMap {
		vulnerabilityCallables := vulnerabilityCallablesMap[vulnerability.ExternalID]
		for _, callableFastenID := range vulnerabilityCallables.CallableFastenIDs {
			callable, ok := callablesMap[callableFastenID]
			if !ok {
				logrus.
					WithField("callableFastenID", callableFastenID).
					WithField("vulnerabilityFastenID", vulnerability.ExternalID).
					Warn("callable present for vulnerability, but missing from FASTEN API response")

				continue
			}

			vulnerabilityJavaCallableMap[vulnerability] = append(vulnerabilityJavaCallableMap[vulnerability], JavaCallable{
				ID:          strconv.Itoa(callable.FastenID),
				PackageName: callable.PackageName,
				ClassName:   callable.ClassName,
				MethodName:  callable.MethodName,
			})
		}
	}

	return vulnerabilityJavaCallableMap
}

func (r *FastenJavaCallableRepository) GetVulnerableCallablesForDependency(ctx context.Context, coordinates maven.Coordinates) (map[vulnerabilities.Vulnerability][]JavaCallable, error) {
	dependencyVulnerabilities, err := r.getVulnerabilitiesForDependency(ctx, coordinates)
	if err != nil {
		return nil, fmt.Errorf("error when fetching vulnerabilities for dependency: %w", err)
	}

	if len(dependencyVulnerabilities) == 0 {
		return nil, nil
	}

	vulnerabilityCallables, err := r.getCallableIdsForVulnerabilities(ctx, dependencyVulnerabilities)
	if err != nil {
		return nil, fmt.Errorf("error when fetching callables for vulnerabilities: %w", err)
	}

	// Collect callable IDs to fetch their metadata
	callableIdsSet := mapset.NewSet[int]()
	for _, vulnerabilityCallable := range vulnerabilityCallables {
		for _, callableId := range vulnerabilityCallable.CallableFastenIDs {
			callableIdsSet.Add(callableId)
		}
	}
	callableIds := callableIdsSet.ToSlice()

	if len(callableIds) == 0 {
		return mapVulnerabilitiesToCallables(vulnerabilityCallables, []fastenJavaCallable{}), nil
	}

	callables, err := r.getCallables(ctx, callableIds)
	if err != nil {
		return nil, fmt.Errorf("error when fetching callables: %w", err)
	}

	// Merge vulnerabilities and their callables together
	return mapVulnerabilitiesToCallables(vulnerabilityCallables, callables), nil
}
