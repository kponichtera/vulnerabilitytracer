package callables

import (
	"testing"

	"vulnerabilitytracer-service/api/generated/fastenapi"
	"vulnerabilitytracer-service/pkg/vulnerabilities"

	"github.com/stretchr/testify/assert"
)

func TestExtractingClassAndMethodNamesFromCallableName(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		arg  fastenapi.PackageVulnerability
		want vulnerabilities.Severity
	}{
		{
			name: "correct vulnerability extracted from correct statement payload",
			arg: fastenapi.PackageVulnerability{
				Statement: map[string]interface{}{
					"severity": "LOW",
				},
			},
			want: vulnerabilities.SeverityLow,
		},
		{
			name: "undefined severity extracted from undefined severity in the statement payload",
			arg: fastenapi.PackageVulnerability{
				Statement: map[string]interface{}{
					"severity": "WEIRDVALUE",
				},
			},
			want: vulnerabilities.SeverityUndefined,
		},
		{
			name: "undefined severity extracted from incorrect statement payload",
			arg: fastenapi.PackageVulnerability{
				Statement: map[string]interface{}{
					"severity": map[string]string{
						"severity": "LOW",
					},
				},
			},
			want: vulnerabilities.SeverityUndefined,
		},

		{
			name: "undefined severity extracted from missing statement payload",
			arg: fastenapi.PackageVulnerability{
				Statement: map[string]interface{}{
					"otherField": "something",
				},
			},
			want: vulnerabilities.SeverityUndefined,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// When
			got := getVulnerabilitySeverity(tt.arg)

			// Then
			assert.Equal(t, tt.want, got)
		})
	}
}

func TestMappingVulnerabilitiesToCallables(t *testing.T) {
	t.Parallel()

	type args struct {
		vulnerabilityCallablesList []vulnerabilityCallables
		fastenJavaCallableList     []fastenJavaCallable
	}

	tests := []struct {
		name string
		args args
		want map[vulnerabilities.Vulnerability][]JavaCallable
	}{
		{
			name: "non-overlapping callables and vulnerabilities are mapped correctly",
			args: args{
				vulnerabilityCallablesList: []vulnerabilityCallables{
					{
						FastenID:          "v1",
						Severity:          vulnerabilities.SeverityLow,
						CallableFastenIDs: []int{1, 2},
					},
					{
						FastenID:          "v2",
						Severity:          vulnerabilities.SeverityMedium,
						CallableFastenIDs: []int{3, 4},
					},
				},
				fastenJavaCallableList: []fastenJavaCallable{
					{FastenID: 1}, {FastenID: 2}, {FastenID: 3}, {FastenID: 4},
				},
			},
			want: map[vulnerabilities.Vulnerability][]JavaCallable{
				{ExternalID: "v1", Severity: vulnerabilities.SeverityLow}: {
					{ExternalID: "1"}, {ExternalID: "2"},
				},
				{ExternalID: "v2", Severity: vulnerabilities.SeverityMedium}: {
					{ExternalID: "3"}, {ExternalID: "4"},
				},
			},
		},
		{
			name: "overlapping callables and vulnerabilities are mapped correctly",
			args: args{
				vulnerabilityCallablesList: []vulnerabilityCallables{
					{
						FastenID:          "v1",
						Severity:          vulnerabilities.SeverityLow,
						CallableFastenIDs: []int{1, 2},
					},
					{
						FastenID:          "v2",
						Severity:          vulnerabilities.SeverityMedium,
						CallableFastenIDs: []int{2, 3},
					},
				},
				fastenJavaCallableList: []fastenJavaCallable{
					{FastenID: 1}, {FastenID: 2}, {FastenID: 3},
				},
			},
			want: map[vulnerabilities.Vulnerability][]JavaCallable{
				{ExternalID: "v1", Severity: vulnerabilities.SeverityLow}: {
					{ExternalID: "1"}, {ExternalID: "2"},
				},
				{ExternalID: "v2", Severity: vulnerabilities.SeverityMedium}: {
					{ExternalID: "2"}, {ExternalID: "3"},
				},
			},
		},
		{
			name: "overlapping callables and vulnerabilities are mapped correctly",
			args: args{
				vulnerabilityCallablesList: []vulnerabilityCallables{
					{
						FastenID:          "v1",
						Severity:          vulnerabilities.SeverityLow,
						CallableFastenIDs: []int{1, 2},
					},
					{
						FastenID:          "v2",
						Severity:          vulnerabilities.SeverityMedium,
						CallableFastenIDs: []int{2, 3},
					},
				},
				fastenJavaCallableList: []fastenJavaCallable{
					{FastenID: 1}, {FastenID: 2}, {FastenID: 3},
				},
			},
			want: map[vulnerabilities.Vulnerability][]JavaCallable{
				{ExternalID: "v1", Severity: vulnerabilities.SeverityLow}: {
					{ExternalID: "1"}, {ExternalID: "2"},
				},
				{ExternalID: "v2", Severity: vulnerabilities.SeverityMedium}: {
					{ExternalID: "2"}, {ExternalID: "3"},
				},
			},
		},
		{
			name: "vulnerability without callables is mapped correctly",
			args: args{
				vulnerabilityCallablesList: []vulnerabilityCallables{
					{
						FastenID:          "v1",
						Severity:          vulnerabilities.SeverityLow,
						CallableFastenIDs: []int{1, 2},
					},
					{
						FastenID:          "v2",
						Severity:          vulnerabilities.SeverityMedium,
						CallableFastenIDs: []int{},
					},
				},
				fastenJavaCallableList: []fastenJavaCallable{
					{FastenID: 1}, {FastenID: 2},
				},
			},
			want: map[vulnerabilities.Vulnerability][]JavaCallable{
				{ExternalID: "v1", Severity: vulnerabilities.SeverityLow}: {
					{ExternalID: "1"}, {ExternalID: "2"},
				},
				{ExternalID: "v2", Severity: vulnerabilities.SeverityMedium}: {},
			},
		},
		{
			name: "vulnerability without correctly resolved callables is mapped without those callables in the result",
			args: args{
				vulnerabilityCallablesList: []vulnerabilityCallables{
					{
						FastenID:          "v1",
						Severity:          vulnerabilities.SeverityLow,
						CallableFastenIDs: []int{1, 2, 3, 4, 5},
					},
				},
				fastenJavaCallableList: []fastenJavaCallable{
					{FastenID: 1}, {FastenID: 2},
				},
			},
			want: map[vulnerabilities.Vulnerability][]JavaCallable{
				{ExternalID: "v1", Severity: vulnerabilities.SeverityLow}: {
					{ExternalID: "1"}, {ExternalID: "2"},
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// When
			got := mapVulnerabilitiesToCallables(tt.args.vulnerabilityCallablesList, tt.args.fastenJavaCallableList)

			// Then
			assert.Equal(t, tt.want, got)
		})
	}
}
