package serviceobserver

import (
	"context"
	"fmt"
	"github.com/go-co-op/gocron"
	"github.com/sirupsen/logrus"
	"os"
	"os/signal"
	"syscall"
	"time"
	"vulnerabilitytracer/pkg/temposcraper/runtime"
)

const observerJobTimeout = 5 * time.Second

type serviceObserverContext struct {
	runtime.Context
}

func Run(config Config) error {
	runtimeCtx, err := runtime.Build(config.Tempo, config.Database)
	if err != nil {
		return fmt.Errorf("error when building runtime context: %w", err)
	}

	defer runtimeCtx.Close()

	serviceObserverCtx := &serviceObserverContext{
		Context: *runtimeCtx,
	}

	scheduler := gocron.NewScheduler(time.UTC).
		SingletonMode().
		Every(5).Seconds()

	_, err = scheduler.DoWithJobDetails(jobFunc, serviceObserverCtx)
	if err != nil {
		return fmt.Errorf("error when scheduling job: %w", err)
	}

	go func() {
		// Shutdown procedure
		shutdown := make(chan os.Signal, 1)
		signal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM)

		received := <-shutdown
		logrus.Infof("%s signal received, shutting down the scheduler", received.String())

		scheduler.Stop()
	}()

	scheduler.StartBlocking()

	logrus.Info("scheduler shutdown complete")
	return nil
}

func jobFunc(runtimeCtx serviceObserverContext, job gocron.Job) {
	_, cancel := context.WithTimeout(job.Context(), observerJobTimeout)
	defer cancel()

	logrus.
		WithField("runCount", job.RunCount()).
		Info("Starting the processor job")
}
