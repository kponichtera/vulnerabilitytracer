package serviceobserver

import (
	"context"
	"fmt"
	mapset "github.com/deckarep/golang-set/v2"
	"github.com/go-co-op/gocron"
	"github.com/sirupsen/logrus"
	"time"
	"vulnerabilitytracer/pkg/temposcraper/runtime"
)

const serviceScraperJobIntervalSeconds = 10

type serviceScraperContext struct {
	runtime.Context
	ServiceName string
}

func reconcile(ctx context.Context, runtimeCtx *serviceObserverContext) error {
	logrus.
		WithField("observedServices", len(runtimeCtx.ObservedServices)).
		Debug("reconciliation loop starting")

	// Get current services from the database
	services, err := runtimeCtx.DBQueries.GetServicesForObserving(ctx)
	if err != nil {
		return fmt.Errorf("error when fetching services from database: %w", err)
	}

	serviceNames := make([]string, len(services))
	for i, service := range services {
		serviceNames[i] = service.Name
	}

	// Stop observing old services
	stopObserving(runtimeCtx, serviceNames)

	// Start observing new services
	err = startObserving(runtimeCtx, serviceNames)
	if err != nil {
		return fmt.Errorf("error when starting to observe services: %w", err)
	}

	logrus.
		WithField("observedServices", len(runtimeCtx.ObservedServices)).
		Debug("reconciliation loop complete")

	return nil
}

func stopObserving(runtimeCtx *serviceObserverContext, serviceNames []string) {
	serviceNamesToStop := make(map[string]*gocron.Scheduler)
	for serviceName, scheduler := range runtimeCtx.ObservedServices {
		serviceNamesToStop[serviceName] = scheduler
	}

	// Remove services that we want to keep observing
	for _, serviceToKeep := range serviceNames {
		delete(serviceNamesToStop, serviceToKeep)
	}

	// Stop the observing schedulers of the services
	for serviceName, scheduler := range serviceNamesToStop {
		logrus.
			WithField("serviceName", serviceName).
			Info("stopping service scraper")

		scheduler.Stop()
		delete(runtimeCtx.ObservedServices, serviceName)
	}
}

func startObserving(runtimeCtx *serviceObserverContext, serviceNames []string) error {
	newServiceNamesToObserve := mapset.NewSet[string](serviceNames...)

	// Remove the services that we are already observing
	for serviceName := range runtimeCtx.ObservedServices {
		newServiceNamesToObserve.Remove(serviceName)
	}

	// Observe new services
	for newServiceName := range newServiceNamesToObserve.Iter() {
		serviceScraperCtx := &serviceScraperContext{
			Context:     runtimeCtx.Context,
			ServiceName: newServiceName,
		}

		scheduler := gocron.NewScheduler(time.UTC).
			SingletonMode().
			Every(serviceScraperJobIntervalSeconds).Seconds()

		_, err := scheduler.DoWithJobDetails(scraperJobFunc, serviceScraperCtx)
		if err != nil {
			return fmt.Errorf("error when scheduling scraper job: %w", err)
		}

		runtimeCtx.ObservedServices[newServiceName] = scheduler

		logrus.
			WithField("serviceName", newServiceName).
			Info("starting service scraper")

		scheduler.StartAsync()
	}

	return nil
}

func scraperJobFunc(runtimeCtx *serviceScraperContext, job gocron.Job) {
	_, cancel := context.WithTimeout(job.Context(), observerJobTimeout)
	defer cancel()

	logrus.Infof("Running scraper for service %s", runtimeCtx.ServiceName)
}
