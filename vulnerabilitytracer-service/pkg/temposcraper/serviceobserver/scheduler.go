package serviceobserver

import (
	"context"
	"fmt"
	"github.com/go-co-op/gocron"
	"github.com/sirupsen/logrus"
	"os"
	"os/signal"
	"syscall"
	"time"
	"vulnerabilitytracer/pkg/temposcraper/runtime"
)

const observerJobTimeout = 5 * time.Second
const serviceObserverJobIntervalSeconds = 5

type serviceObserverContext struct {
	runtime.Context
	ObservedServices map[string]*gocron.Scheduler
}

func Run(config Config) error {
	runtimeCtx, err := runtime.Build(config.Tempo, config.Database)
	if err != nil {
		return fmt.Errorf("error when building runtime context: %w", err)
	}

	defer runtimeCtx.Close()

	serviceObserverCtx := &serviceObserverContext{
		Context:          *runtimeCtx,
		ObservedServices: make(map[string]*gocron.Scheduler),
	}

	scheduler := gocron.NewScheduler(time.UTC).
		SingletonMode().
		Every(serviceObserverJobIntervalSeconds).Seconds()

	_, err = scheduler.DoWithJobDetails(observerJobFunc, serviceObserverCtx)
	if err != nil {
		return fmt.Errorf("error when scheduling observer job: %w", err)
	}

	go func() {
		// Shutdown procedure
		shutdown := make(chan os.Signal, 1)
		signal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM)

		received := <-shutdown
		logrus.Infof("%s signal received, shutting down the scrapers", received.String())

		for serviceName, scraperScheduler := range serviceObserverCtx.ObservedServices {
			logrus.Infof("shutting down the scraper for service %s", serviceName)
			scraperScheduler.Stop()
		}

		logrus.Info("shutting down the observer")
		scheduler.Stop()
	}()

	scheduler.StartBlocking()

	logrus.Info("scheduler shutdown complete")
	return nil
}

func observerJobFunc(runtimeCtx *serviceObserverContext, job gocron.Job) {
	ctx, cancel := context.WithTimeout(job.Context(), observerJobTimeout)
	defer cancel()

	err := reconcile(ctx, runtimeCtx)
	if err != nil {
		logrus.WithError(err).Error("error during reconciliation")
	}
}
