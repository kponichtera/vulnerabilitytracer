package servicescraper

import (
	"context"
	"fmt"
	"time"

	"vulnerabilitytracer/pkg/temposcraper/runtime"
	"vulnerabilitytracer/pkg/temposcraper/tempoquerier"

	"github.com/sirupsen/logrus"
)

type Context struct {
	runtime.Context
	ServiceName    string
	ScrapeDelay    time.Duration
	ScrapeInterval time.Duration
}

func Scrape(ctx context.Context, runtimeCtx *Context) error {
	// Determine interval to scrape (search for trace IDs in Tempo)
	startTime := time.Now().Add(-runtimeCtx.ScrapeDelay).Add(-runtimeCtx.ScrapeInterval)
	endTime := startTime.Add(runtimeCtx.ScrapeInterval)

	logrus.
		WithField("from", startTime).
		WithField("to", endTime).
		Infof("Running scraper for service %s", runtimeCtx.ServiceName)

	// Search Tempo for trace IDs
	traceIDs, err := searchTempoTraces(ctx, runtimeCtx.Context, runtimeCtx.ServiceName, startTime, endTime)
	if err != nil {
		return fmt.Errorf("error when searching for traces: %w", err)
	}

	// TODO: Persist traces in the database, for further scraping by another service

	logrus.
		WithField("from", startTime).
		WithField("to", endTime).
		WithField("traceCount", len(traceIDs)).
		Info("finished scraping trace identifiers")

	return nil
}

// searchTempoTraces returns a list of trace IDs of the given service from the provided time range
func searchTempoTraces(ctx context.Context, runtimeCtx runtime.Context,
	serviceName string, from time.Time, to time.Time,
) ([]string, error) {
	result, err := tempoquerier.TraceSearch(ctx, runtimeCtx.TempoQuerierClient, serviceName, from, to)
	if err != nil {
		return nil, fmt.Errorf("error when searching for service traces of service %s: %w", serviceName, err)
	}

	traceIDs := make([]string, 0)
	for _, trace := range result {
		traceIDs = append(traceIDs, *trace.TraceID)
	}

	logrus.
		WithField("serviceName", serviceName).
		WithField("traceCount", len(traceIDs)).
		Info("finished searching for Tempo traces")

	return traceIDs, nil
}
