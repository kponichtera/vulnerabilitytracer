package servicescraper

import (
	"context"
	"fmt"
	"github.com/jackc/pgx/v5/pgtype"
	"strconv"
	"time"
	"vulnerabilitytracer/db/generated/queries"

	"vulnerabilitytracer/pkg/temposcraper/runtime"
	"vulnerabilitytracer/pkg/temposcraper/tempoquerier"

	"github.com/sirupsen/logrus"
)

type Context struct {
	runtime.Context
	ServiceName    string
	ScrapeDelay    time.Duration
	ScrapeInterval time.Duration
}

func Scrape(ctx context.Context, runtimeCtx *Context) error {
	// Determine interval to scrape (search for trace IDs in Tempo)
	startTime := time.Now().Add(-runtimeCtx.ScrapeDelay).Add(-runtimeCtx.ScrapeInterval)
	endTime := startTime.Add(runtimeCtx.ScrapeInterval)

	logrus.
		WithField("from", startTime).
		WithField("to", endTime).
		Infof("running scraper for service %s", runtimeCtx.ServiceName)

	// Search Tempo for trace IDs
	traceResults, err := searchTempoTraces(ctx, runtimeCtx, startTime, endTime)
	if err != nil {
		return fmt.Errorf("error when searching for traces: %w", err)
	}

	// Persist traces in the database, for further scraping by another service
	err = persistTempoTraces(ctx, runtimeCtx, traceResults)
	if err != nil {
		return fmt.Errorf("error when persisting traces: %w", err)
	}

	logrus.
		WithField("from", startTime).
		WithField("to", endTime).
		WithField("traceCount", len(traceResults)).
		WithField("serviceName", runtimeCtx.ServiceName).
		Info("finished scraping trace identifiers")

	return nil
}

type traceSearchResult struct {
	TraceID        string
	TraceStartTime time.Time
}

// searchTempoTraces returns a list of trace IDs of the given service from the provided time range
func searchTempoTraces(ctx context.Context, runtimeCtx *Context,
	from time.Time, to time.Time,
) ([]traceSearchResult, error) {
	serviceName := runtimeCtx.ServiceName

	result, err := tempoquerier.TraceSearch(ctx, runtimeCtx.TempoQuerierClient, serviceName, from, to)
	if err != nil {
		return nil, fmt.Errorf("error when searching for service traces of service %s: %w", serviceName, err)
	}

	traceResults := make([]traceSearchResult, 0)

	for _, trace := range result {
		traceStartUnixNano, err := strconv.Atoi(trace.StartTimeUnixNano)
		if err != nil {
			return nil, fmt.Errorf("provided trace start time (%s) is not a valid integer: %w", trace.StartTimeUnixNano, err)
		}

		traceResult := traceSearchResult{
			TraceID:        trace.TraceID,
			TraceStartTime: time.Unix(0, int64(traceStartUnixNano)),
		}
		traceResults = append(traceResults, traceResult)

		logrus.
			WithField("serviceName", serviceName).
			WithField("traceID", traceResult.TraceID).
			WithField("traceStartTime", traceResult.TraceStartTime).
			Trace("scraped trace from Tempo")
	}

	logrus.
		WithField("serviceName", serviceName).
		WithField("traceCount", len(traceResults)).
		Debug("finished searching for Tempo traces")

	return traceResults, nil
}

func persistTempoTraces(ctx context.Context, runtimeCtx *Context, traceResults []traceSearchResult) error {
	serviceName := runtimeCtx.ServiceName

	for _, trace := range traceResults {
		err := runtimeCtx.DBQueries.InsertTrace(ctx, queries.InsertTraceParams{
			TempoID: trace.TraceID,
			Time: pgtype.Timestamptz{
				Time:  trace.TraceStartTime,
				Valid: true,
			},
			ServiceName: serviceName,
		})
		if err != nil {
			return fmt.Errorf("error when inserting trace: %w", err)
		}

		logrus.
			WithField("serviceName", serviceName).
			WithField("traceID", trace.TraceID).
			WithField("traceStartTime", trace.TraceStartTime).
			Trace("finished persisting Tempo trace")
	}

	logrus.
		WithField("serviceName", serviceName).
		WithField("traceCount", len(traceResults)).
		Debug("finished persisting Tempo traces")

	return nil
}
