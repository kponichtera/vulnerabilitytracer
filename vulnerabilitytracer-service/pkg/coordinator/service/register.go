package service

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"

	"vulnerabilitytracer/api/generated/coordinatorapi"
	"vulnerabilitytracer/pkg/coordinator/callables"
	"vulnerabilitytracer/pkg/coordinator/runtime"

	"vulnerabilitytracer/db/generated/queries"
	"vulnerabilitytracer/pkg/maven"

	"github.com/jackc/pgx/v5"
	"github.com/mitchellh/hashstructure/v2"
	"github.com/sirupsen/logrus"
)

var ErrRegisteringDependencies = errors.New("error when registering dependencies")

func Register(ctx context.Context, runtimeCtx runtime.Context,
	serviceName string, dependencies []coordinatorapi.MavenCoordinates,
) ([]coordinatorapi.JavaCallable, error) {
	tx, err := runtimeCtx.DBPool.BeginTx(ctx, pgx.TxOptions{
		IsoLevel: pgx.ReadCommitted,
	})
	if err != nil {
		return nil, fmt.Errorf("error when starting transaction: %w", err)
	}
	defer tx.Commit(ctx)

	existingServiceId, err := CheckServiceRegistration(ctx, runtimeCtx, tx, serviceName, dependencies)
	if err != nil {
		tx.Rollback(ctx)
		return nil, err
	}

	if existingServiceId == nil {
		// Service was not registered previously - register it and its dependencies
		serviceID, err := RegisterService(ctx, runtimeCtx, tx, serviceName, dependencies)
		if err != nil {
			tx.Rollback(ctx)
			return nil, err
		}

		dependencyIDs, err := RegisterServiceDependencies(ctx, runtimeCtx, tx, serviceID, dependencies)
		if err != nil {
			tx.Rollback(ctx)
			return nil, err
		}

		vulnerableCallables, err := RegisterVulnerabilitiesAndCallables(ctx, runtimeCtx, tx, dependencyIDs)
		if err != nil {
			tx.Rollback(ctx)
			return nil, err
		}

		return vulnerableCallables, nil
	}

	// Service was registered previously - return its vulnerable callables
	vulnerableCallables, err := QueryServiceVulnerableCallables(ctx, runtimeCtx, *existingServiceId)
	if err != nil {
		tx.Rollback(ctx)
		return nil, err
	}

	// If service was restarted, dismiss notifications asking for a restart
	err = DismissServiceRestartNotifications(ctx, runtimeCtx, tx, *existingServiceId)
	if err != nil {
		tx.Rollback(ctx)
		return nil, err
	}

	return vulnerableCallables, nil
}

func CheckServiceRegistration(ctx context.Context, runtimeCtx runtime.Context, tx pgx.Tx,
	serviceName string, dependencies []coordinatorapi.MavenCoordinates,
) (*int64, error) {
	dependenciesHash, err := computeDependenciesHash(dependencies)
	if err != nil {
		return nil, fmt.Errorf("error when computing dependencies hash: %w", err)
	}

	serviceID, err := runtimeCtx.DBQueries.WithTx(tx).GetServiceForRegistration(ctx, queries.GetServiceForRegistrationParams{
		Name:             serviceName,
		DependenciesHash: dependenciesHash,
	})
	if err != nil && errors.Is(err, pgx.ErrNoRows) {
		return nil, nil
	} else if err != nil {
		return nil, fmt.Errorf("error when fetching service from database: %w", err)
	}

	logrus.
		WithField("serviceID", serviceID).
		WithField("serviceName", serviceName).
		WithField("dependenciesHash", dependenciesHash).
		Info("service already registered")

	// Service exists
	return &serviceID, nil
}

func RegisterService(ctx context.Context, runtimeCtx runtime.Context, tx pgx.Tx,
	serviceName string, dependencies []coordinatorapi.MavenCoordinates,
) (int64, error) {
	dependenciesHash, err := computeDependenciesHash(dependencies)
	if err != nil {
		return 0, fmt.Errorf("error when computing dependencies hash: %w", err)
	}

	// Service does not exist yet, register it
	serviceID, err := runtimeCtx.DBQueries.WithTx(tx).RegisterNewService(ctx, queries.RegisterNewServiceParams{
		Name:             serviceName,
		DependenciesHash: dependenciesHash,
	})
	if err != nil {
		return 0, fmt.Errorf("error when saving service to database: %w", err)
	}

	logrus.
		WithField("serviceID", serviceID).
		WithField("serviceName", serviceName).
		WithField("dependenciesHash", dependenciesHash).
		Info("registered new service")

	return serviceID, nil
}

// checkFastenDependencyProcessingStatus check if FASTEN has processed this dependency before
func checkFastenDependencyProcessingStatus(ctx context.Context, runtimeCtx runtime.Context, dependency maven.Coordinates) (bool, error) {
	processingStatus, err := runtimeCtx.FastenCallableRepository.GetDependencyProcessingStatus(ctx, dependency)
	if err != nil {
		return false, fmt.Errorf("error when checking dependency processing status: %w", err)
	}

	return processingStatus == callables.Processed, nil
}

func registerDependency(ctx context.Context, runtimeCtx runtime.Context, tx pgx.Tx,
	dependency maven.Coordinates, fastenProcessed bool,
) (int64, error) {
	dependencyID, err := runtimeCtx.DBQueries.WithTx(tx).RegisterNewDependency(ctx, queries.RegisterNewDependencyParams{
		GroupID:         dependency.GroupID,
		ArtifactID:      dependency.ArtifactID,
		Version:         dependency.Version,
		FastenProcessed: fastenProcessed,
	})
	if err != nil {
		return 0, fmt.Errorf("error when registering new dependency: %w", err)
	}

	logrus.
		WithField("dependencyID", dependencyID).
		WithField("groupID", dependency.GroupID).
		WithField("artifactID", dependency.ArtifactID).
		WithField("version", dependency.Version).
		WithField("fastenProcessed", fastenProcessed).
		Info("registered new dependency")

	return dependencyID, nil
}

func RegisterServiceDependencies(ctx context.Context, runtimeCtx runtime.Context, tx pgx.Tx,
	serviceID int64, dependencies []coordinatorapi.MavenCoordinates,
) (map[maven.Coordinates]int64, error) {
	type dependencyAndProcessingStatus struct {
		Coordinates     maven.Coordinates
		FastenProcessed bool
	}
	type dependencyAndId struct {
		Coordinates maven.Coordinates
		ID          int64
	}

	// Look for already registered dependencies
	registeredDependencies := make([]dependencyAndId, 0)
	dependenciesToRegister := make([]coordinatorapi.MavenCoordinates, 0)
	for _, d := range dependencies {
		dependencyID, err := runtimeCtx.DBQueries.WithTx(tx).GetRegisteredDependencyId(ctx, queries.GetRegisteredDependencyIdParams{
			GroupID:    d.GroupId,
			ArtifactID: d.ArtifactId,
			Version:    d.Version,
		})
		if err == nil {
			registeredDependencies = append(registeredDependencies, dependencyAndId{
				Coordinates: maven.ConvertAPICoordinates(d),
				ID:          dependencyID,
			})
		} else if err != nil && errors.Is(err, pgx.ErrNoRows) {
			dependenciesToRegister = append(dependenciesToRegister, d)
		} else {
			return nil, fmt.Errorf("error when fetching registered dependency: %w", err)
		}
	}

	logrus.
		WithField("registeredCount", len(registeredDependencies)).
		WithField("toRegisterCount", len(dependenciesToRegister)).
		Info("finished checking for already registered dependencies")

	// Register new dependencies
	waitGroup := new(sync.WaitGroup)
	succChan := make(chan dependencyAndProcessingStatus)
	errChan := make(chan error)

	for _, d := range dependenciesToRegister {
		coordinates := maven.ConvertAPICoordinates(d)

		waitGroup.Add(1)

		go func() {
			defer waitGroup.Done()

			processed, err := checkFastenDependencyProcessingStatus(ctx, runtimeCtx, coordinates)
			if err != nil {
				errChan <- err
			} else {
				succChan <- dependencyAndProcessingStatus{
					Coordinates:     coordinates,
					FastenProcessed: processed,
				}
			}
		}()
	}

	processingStatuses := make(map[maven.Coordinates]bool)

	go func() {
		waitGroup.Wait()
		close(succChan)
		close(errChan)
	}()

	errorCount := 0
	succChanClosed := false
	errChanClosed := false

	for {
		select {
		case processingStatus, ok := <-succChan:
			if !ok {
				succChanClosed = true
			} else {
				processingStatuses[processingStatus.Coordinates] = processingStatus.FastenProcessed
			}
		case err, ok := <-errChan:
			if !ok {
				errChanClosed = true
			} else {
				logrus.
					WithError(err).
					Error("error when checking dependency processing status in FASTEN")
				errorCount++
			}
		}

		if succChanClosed && errChanClosed {
			break
		}
	}

	dependencyIDs := make(map[maven.Coordinates]int64)

	for dependency, processingStatus := range processingStatuses {
		dependencyID, err := registerDependency(ctx, runtimeCtx, tx, dependency, processingStatus)
		if err != nil {
			return nil, fmt.Errorf("error when registering dependency: %w", err)
		}

		dependencyIDs[dependency] = dependencyID
	}

	logrus.
		WithField("success", len(dependencyIDs)).
		WithField("errorCount", errorCount).
		Info("finished registering dependencies")

	if errorCount > 0 {
		return nil, ErrRegisteringDependencies
	}

	// Add the previously registered dependencies to the map
	for _, dependencyAndId := range registeredDependencies {
		dependencyIDs[dependencyAndId.Coordinates] = dependencyAndId.ID
	}

	// Link dependencies to service
	serviceDependencies := make([]queries.RegisterServiceDependenciesParams, 0)
	for _, dependencyID := range dependencyIDs {
		serviceDependencies = append(serviceDependencies, queries.RegisterServiceDependenciesParams{
			ServiceID:    serviceID,
			DependencyID: dependencyID,
		})
	}

	registeredDependenciesCount, err := runtimeCtx.DBQueries.WithTx(tx).RegisterServiceDependencies(ctx, serviceDependencies)
	if err != nil {
		return nil, fmt.Errorf("error when registering new dependencies for the service: %w", err)
	}

	logrus.
		WithField("serviceID", serviceID).
		WithField("dependencyCount", registeredDependenciesCount).
		Info("registered dependencies for service")

	return dependencyIDs, nil
}

func computeDependenciesHash(dependencies []coordinatorapi.MavenCoordinates) (string, error) {
	hash, err := hashstructure.Hash(dependencies, hashstructure.FormatV2, nil)
	if err != nil {
		return "", err
	}

	return strconv.FormatUint(hash, 16), nil
}
