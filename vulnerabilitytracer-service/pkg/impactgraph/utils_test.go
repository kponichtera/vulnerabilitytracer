package impactgraph_test

import (
	"github.com/google/uuid"
	"github.com/stretchr/testify/require"
	"testing"
	"vulnerabilitytracer/pkg/impactgraph"
)

func TestFindingImpactGraphRoot(t *testing.T) {
	t.Parallel()

	correctGraph, correctRoot := buildCorrectImpactGraph()
	cyclicGraph, _ := buildCyclicImpactGraph()

	tests := []struct {
		name             string
		graph            impactgraph.Graph
		expectedRootUUID uuid.UUID
		expectedError    error
	}{
		{
			name:             "finding root in correct impact graph works",
			graph:            correctGraph,
			expectedRootUUID: correctRoot,
			expectedError:    nil,
		},
		{
			name:             "finding root in cyclic impact graph returns error",
			graph:            cyclicGraph,
			expectedRootUUID: uuid.Nil,
			expectedError:    impactgraph.ErrGraphNotRooted,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// When
			root, err := impactgraph.FindRoot(tt.graph)

			// Then
			if tt.expectedError != nil {
				require.Error(t, tt.expectedError)
			} else {
				require.NoError(t, err)
				require.Equal(t, tt.expectedRootUUID, *root)
			}
		})
	}
}

func TestCheckingImpactGraphEquality(t *testing.T) {
	graph1, _ := buildCorrectImpactGraph()
	graph2, _ := buildCyclicImpactGraph()

	tests := []struct {
		name           string
		graph1         impactgraph.Graph
		graph2         impactgraph.Graph
		expectedResult bool
		expectedError  error
	}{
		{
			name:           "checking equality of two equal graphs works",
			graph1:         graph1,
			graph2:         graph1,
			expectedResult: true,
			expectedError:  nil,
		},
		{
			name:           "checking equality of two different graphs works",
			graph1:         graph1,
			graph2:         graph2,
			expectedResult: false,
			expectedError:  nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// When
			result, err := impactgraph.Equal(tt.graph1, tt.graph2)

			// Then
			if tt.expectedError != nil {
				require.Error(t, tt.expectedError)
			} else {
				require.NoError(t, err)
				require.Equal(t, tt.expectedResult, result)
			}
		})
	}
}

func buildCorrectImpactGraph() (impactgraph.Graph, uuid.UUID) {
	uuids := generateUUIDs(3)

	resultGraph := impactgraph.NewGraph()
	_ = resultGraph.AddVertex(impactgraph.Node{
		TempoID:     "tempo-id-1",
		ServiceName: "service-1",
		UUID:        uuids[0],
	})
	_ = resultGraph.AddVertex(impactgraph.Node{
		TempoID:     "tempo-id-2",
		ServiceName: "service-2",
		UUID:        uuids[1],
	})
	_ = resultGraph.AddVertex(impactgraph.Node{
		TempoID:     "tempo-id-3",
		ServiceName: "service-3",
		UUID:        uuids[2],
	})
	_ = resultGraph.AddEdge(uuids[0], uuids[1])
	_ = resultGraph.AddEdge(uuids[1], uuids[2])

	return resultGraph, uuids[0]
}

func buildCyclicImpactGraph() (impactgraph.Graph, uuid.UUID) {
	uuids := generateUUIDs(3)

	resultGraph := impactgraph.NewGraph()
	_ = resultGraph.AddVertex(impactgraph.Node{
		TempoID:     "tempo-id-1",
		ServiceName: "service-1",
		UUID:        uuids[0],
	})
	_ = resultGraph.AddVertex(impactgraph.Node{
		TempoID:     "tempo-id-2",
		ServiceName: "service-2",
		UUID:        uuids[1],
	})
	_ = resultGraph.AddVertex(impactgraph.Node{
		TempoID:     "tempo-id-3",
		ServiceName: "service-3",
		UUID:        uuids[2],
	})
	_ = resultGraph.AddEdge(uuids[0], uuids[1])
	_ = resultGraph.AddEdge(uuids[1], uuids[2])
	_ = resultGraph.AddEdge(uuids[2], uuids[0])

	return resultGraph, uuids[0]
}

func generateUUIDs(count int) []uuid.UUID {
	uuids := make([]uuid.UUID, count)
	for i := 0; i < count; i++ {
		uuids[i] = uuid.New()
	}

	return uuids
}
