package impactgraph

import (
	"fmt"
	"github.com/dominikbraun/graph"
	"github.com/google/uuid"
)

func ReduceImpactGraph(impactGraph graph.Graph[uuid.UUID, Node]) (graph.Graph[uuid.UUID, Node], error) {
	reducedGraph, err := impactGraph.Clone()
	if err != nil {
		return nil, fmt.Errorf("failed to clone impact graph: %w", err)
	}

	searchRoot, err := FindRoot(reducedGraph)
	if err != nil {
		return nil, fmt.Errorf("failed to find root in impact graph: %w", err)
	}

	for {
		var nodeUUIDToReduce, successorUUID uuid.UUID

		predecessorMap, err := reducedGraph.PredecessorMap()
		if err != nil {
			return nil, fmt.Errorf("failed to get predecessor map: %w", err)
		}

		successorMap, err := reducedGraph.AdjacencyMap()
		if err != nil {
			return nil, fmt.Errorf("failed to get successor map: %w", err)
		}

		err = graph.BFS(reducedGraph, *searchRoot, func(nodeUUID uuid.UUID) bool {
			node, _ := reducedGraph.Vertex(nodeUUID)
			predecessors := predecessorMap[nodeUUID]
			for predecessorUUID := range predecessors {
				// Check if there is any predecessor with the same service name
				predecessorNode, _ := reducedGraph.Vertex(predecessorUUID)
				if predecessorNode.ServiceName == node.ServiceName {
					successorUUID = nodeUUID
					nodeUUIDToReduce = predecessorUUID

					return true
				}
			}

			return false
		})
		if err != nil {
			return nil, fmt.Errorf("failed to perform search on the impact graph: %w", err)
		}

		if nodeUUIDToReduce == uuid.Nil {
			// No more nodes to reduce
			break
		}

		// Handle incoming edges of the reduced node
		incomingEdges := predecessorMap[nodeUUIDToReduce]
		for predecessorUUID := range incomingEdges {
			// Connect incoming edges of reduced node to successor
			err := reducedGraph.AddEdge(predecessorUUID, successorUUID)
			if err != nil {
				return nil, fmt.Errorf("failed to connect incoming edge of reduced node to successor: %w", err)
			}

			// Disconnect the incoming edges of the reduced node
			err = reducedGraph.RemoveEdge(predecessorUUID, nodeUUIDToReduce)
			if err != nil {
				return nil, fmt.Errorf("failed to disconnect the outgoing edge of the reduced node: %w", err)
			}
		}

		// Handle outgoing edges of the reduced node
		outgoingEdges := successorMap[nodeUUIDToReduce]
		for reducedSuccessorUUID := range outgoingEdges {
			// Connect the outgoing edges of the reduced node to its successor
			if reducedSuccessorUUID != successorUUID {
				err := reducedGraph.AddEdge(successorUUID, reducedSuccessorUUID)
				if err != nil {
					return nil, fmt.Errorf("failed to connect outgoing edge of reduced node to successor: %w", err)
				}
			}

			// Disconnect the outgoing edges of the reduced node
			err = reducedGraph.RemoveEdge(nodeUUIDToReduce, reducedSuccessorUUID)
			if err != nil {
				return nil, fmt.Errorf("failed to disconnect the outgoing edge of the reduced node: %w", err)
			}
		}

		// Remove the node from the graph
		err = reducedGraph.RemoveVertex(nodeUUIDToReduce)
		if err != nil {
			return nil, fmt.Errorf("failed to remove node from the impact graph: %w", err)
		}

		// Set the new search root to predecessor
		//searchRoot = &successorUUID
	}

	return reducedGraph, nil
}
