package service

import (
	"context"
	"github.com/sirupsen/logrus"
	"sync"
	"vulnerabilitytracer-service/api/generated/api"
	"vulnerabilitytracer-service/pkg/callables"
	"vulnerabilitytracer-service/pkg/maven"
	"vulnerabilitytracer-service/pkg/server/runtime"
	"vulnerabilitytracer-service/pkg/vulnerabilities"
)

func FetchVulnerabilitiesAndCallables(ctx context.Context, runtimeCtx runtime.Context, dependencies []api.MavenCoordinates) ([]int64, error) {
	type dependencyVulnerabilitiesAndCallables struct {
		Coordinates               maven.Coordinates
		VulnerabilityCallablesMap map[vulnerabilities.Vulnerability][]callables.JavaCallable
	}

	vulnerabilityCallablesMap := make(map[vulnerabilities.Vulnerability][]callables.JavaCallable)
	dependencyVulnerabilitiesMap := make(map[maven.Coordinates][]vulnerabilities.Vulnerability)

	// Query repository for vulnerabilities and callables in the dependencies
	waitGroup := new(sync.WaitGroup)
	succChan := make(chan dependencyVulnerabilitiesAndCallables)
	errChan := make(chan error)

	for _, dependency := range dependencies {
		coordinates := maven.Coordinates{
			ArtifactID: dependency.ArtifactId,
			GroupID:    dependency.GroupId,
			Version:    dependency.Version,
		}

		waitGroup.Add(1)
		go func() {
			defer waitGroup.Done()

			vulnerabilityCallablesMap, err := runtimeCtx.FastenCallableRepository.GetVulnerableCallablesForDependency(ctx, coordinates)
			if err != nil {
				errChan <- err
			} else {
				succChan <- dependencyVulnerabilitiesAndCallables{
					Coordinates:               coordinates,
					VulnerabilityCallablesMap: vulnerabilityCallablesMap,
				}
			}
		}()
	}

	go func() {
		waitGroup.Wait()
		close(succChan)
		close(errChan)
	}()

	errorCount := 0
	succChanClosed := false
	errChanClosed := false

	for {
		select {
		case dvc, ok := <-succChan:
			if !ok {
				succChanClosed = true
			} else {
				// Save mapping between dependency and its vulnerabilities
				dependencyVulnerabilities := make([]vulnerabilities.Vulnerability, 0)
				for vulnerability := range dvc.VulnerabilityCallablesMap {
					dependencyVulnerabilities = append(dependencyVulnerabilities, vulnerability)
				}
				dependencyVulnerabilitiesMap[dvc.Coordinates] = append(dependencyVulnerabilitiesMap[dvc.Coordinates], dependencyVulnerabilities...)

				// Save mapping between vulnerabilities and their callables
				for vulnerability, callablesList := range dvc.VulnerabilityCallablesMap {
					vulnerabilityCallablesMap[vulnerability] = append(vulnerabilityCallablesMap[vulnerability], callablesList...)
				}
			}
		case err, ok := <-errChan:
			if !ok {
				errChanClosed = true
			} else {
				logrus.
					WithError(err).
					Error("error when fetching vulnerabilities and callables")
				errorCount++
			}
		}

		if succChanClosed && errChanClosed {
			break
		}
	}

	logrus.
		WithField("vulnerabilityCount", len(vulnerabilityCallablesMap)).
		WithField("dependencyCount", len(dependencyVulnerabilitiesMap)).
		WithField("errorCount", errorCount).
		Info("fetched vulnerabilities and callables from FASTEN")

	// TODO: Persist vulnerabilities and their callables in the database
	// TODO: Return vulnerability identifiers

	return nil, nil
}
