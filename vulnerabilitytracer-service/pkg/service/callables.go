package service

import (
	"context"
	"fmt"
	"sync"

	"vulnerabilitytracer-service/api/generated/api"
	"vulnerabilitytracer-service/db/generated/queries"
	"vulnerabilitytracer-service/pkg/callables"
	"vulnerabilitytracer-service/pkg/maven"
	"vulnerabilitytracer-service/pkg/server/runtime"
	"vulnerabilitytracer-service/pkg/vulnerabilities"

	mapset "github.com/deckarep/golang-set/v2"
	"github.com/sirupsen/logrus"
)

func getVulnerabileCallablesForDependencies(ctx context.Context, runtimeCtx runtime.Context, dependencies []api.MavenCoordinates) (map[vulnerabilities.Vulnerability][]callables.JavaCallable, map[maven.Coordinates][]vulnerabilities.Vulnerability) {
	type dependencyVulnerabilitiesAndCallables struct {
		Coordinates               maven.Coordinates
		VulnerabilityCallablesMap map[vulnerabilities.Vulnerability][]callables.JavaCallable
	}

	vulnerabilityCallablesMap := make(map[vulnerabilities.Vulnerability][]callables.JavaCallable)
	dependencyVulnerabilitiesMap := make(map[maven.Coordinates][]vulnerabilities.Vulnerability)

	// Query repository for vulnerabilities and callables in the dependencies
	waitGroup := new(sync.WaitGroup)
	succChan := make(chan dependencyVulnerabilitiesAndCallables)
	errChan := make(chan error)

	for _, dependency := range dependencies {
		coordinates := maven.Coordinates{
			ArtifactID: dependency.ArtifactId,
			GroupID:    dependency.GroupId,
			Version:    dependency.Version,
		}

		waitGroup.Add(1)
		go func() {
			defer waitGroup.Done()

			vulnerabilityCallablesMap, err := runtimeCtx.FastenCallableRepository.GetVulnerableCallablesForDependency(ctx, coordinates)
			if err != nil {
				errChan <- err
			} else {
				succChan <- dependencyVulnerabilitiesAndCallables{
					Coordinates:               coordinates,
					VulnerabilityCallablesMap: vulnerabilityCallablesMap,
				}
			}
		}()
	}

	go func() {
		waitGroup.Wait()
		close(succChan)
		close(errChan)
	}()

	errorCount := 0
	succChanClosed := false
	errChanClosed := false

	for {
		select {
		case dvc, ok := <-succChan:
			if !ok {
				succChanClosed = true
			} else {
				// Save mapping between dependency and its vulnerabilities
				dependencyVulnerabilities := make([]vulnerabilities.Vulnerability, 0)
				for vulnerability := range dvc.VulnerabilityCallablesMap {
					dependencyVulnerabilities = append(dependencyVulnerabilities, vulnerability)
				}
				dependencyVulnerabilitiesMap[dvc.Coordinates] = append(dependencyVulnerabilitiesMap[dvc.Coordinates], dependencyVulnerabilities...)

				// Save mapping between vulnerabilities and their callables
				for vulnerability, callablesList := range dvc.VulnerabilityCallablesMap {
					vulnerabilityCallablesMap[vulnerability] = append(vulnerabilityCallablesMap[vulnerability], callablesList...)
				}
			}
		case err, ok := <-errChan:
			if !ok {
				errChanClosed = true
			} else {
				logrus.
					WithError(err).
					Error("error when fetching vulnerabilities and callables")
				errorCount++
			}
		}

		if succChanClosed && errChanClosed {
			break
		}
	}

	logrus.
		WithField("vulnerabilityCount", len(vulnerabilityCallablesMap)).
		WithField("dependencyCount", len(dependencyVulnerabilitiesMap)).
		WithField("errorCount", errorCount).
		Info("fetched vulnerabilities and callables from FASTEN")

	return vulnerabilityCallablesMap, dependencyVulnerabilitiesMap
}

func registerVulnerabilitiesAndCallables(ctx context.Context, runtimeCtx runtime.Context,
	vulnerabilityCallablesMap map[vulnerabilities.Vulnerability][]callables.JavaCallable,
	dependencyVulnerabilitiesMap map[maven.Coordinates][]vulnerabilities.Vulnerability) (map[vulnerabilities.Vulnerability]int64, error) {

	// Fetch vulnerabilities and callables, currently in the database
	newVulnerabilityExternalIds := mapset.NewSet[string]()
	newCallableFastenIds := mapset.NewSet[string]()

	for vulnerability, callablesList := range vulnerabilityCallablesMap {
		newVulnerabilityExternalIds.Add(vulnerability.ExternalID)
		for _, c := range callablesList {
			newCallableFastenIds.Add(c.ExternalID)
		}
	}

	// Fetch existing vulnerabilities from the database
	registeredVulnerabilities, err := runtimeCtx.DBQueries.GetVulnerabilitiesForRegistration(ctx, newVulnerabilityExternalIds.ToSlice())
	if err != nil {
		return nil, fmt.Errorf("error when fetching registered vulnerabilities from database: %w", err)
	}

	existingVulnerabilityDatabaseIds := make(map[string]int64)
	existingVulnerabilityExternalIds := mapset.NewSet[string]()

	for _, v := range registeredVulnerabilities {
		existingVulnerabilityExternalIds.Add(v.ExternalID)
		existingVulnerabilityDatabaseIds[v.ExternalID] = v.ID
	}

	// Fetch existing callables from the database
	registeredCallables, err := runtimeCtx.DBQueries.GetCallablesForRegistration(ctx, newCallableFastenIds.ToSlice())
	if err != nil {
		return nil, fmt.Errorf("error when fetching registered callables from database: %w", err)
	}

	existingCallableDatabaseIds := make(map[string]int64)
	existingCallableFastenIds := mapset.NewSet[string]()

	for _, c := range registeredCallables {
		existingCallableFastenIds.Add(c.FastenID)
		existingCallableDatabaseIds[c.FastenID] = c.ID
	}

	// Persist new vulnerabilities and their callables in the database
	vulnerabilityExternalIdsToPersist := newVulnerabilityExternalIds.Difference(existingVulnerabilityExternalIds)
	callableFastenIdsToPersist := newCallableFastenIds.Difference(existingCallableFastenIds)

	registeredVulnerabilityIds := make(map[vulnerabilities.Vulnerability]int64)

	for vulnerability, callablesList := range vulnerabilityCallablesMap {
		var vulnerabilityID int64

		// Persist vulnerability if it does not exist
		if vulnerabilityExternalIdsToPersist.Contains(vulnerability.ExternalID) {
			newVulnerabilityID, err := runtimeCtx.DBQueries.RegisterNewVulnerability(ctx, queries.RegisterNewVulnerabilityParams{
				ExternalID: vulnerability.ExternalID,
				Severity:   string(vulnerability.Severity),
			})
			if err != nil {
				return nil, fmt.Errorf("error when registering new vulnerability: %w", err)
			}

			vulnerabilityID = newVulnerabilityID
		} else {
			// Vulnerability already exists, get its database ID for linking with the callables
			vulnerabilityID = existingVulnerabilityDatabaseIds[vulnerability.ExternalID]
		}
		registeredVulnerabilityIds[vulnerability] = vulnerabilityID

		vulnerabilityCallableRelation := make([]queries.RegisterVulnerabilityCallableRelationsParams, len(callablesList))

		// Persist callables if it does not exist
		for i, callable := range callablesList {
			var callableID int64
			if callableFastenIdsToPersist.Contains(callable.ExternalID) {
				newCallableId, err := runtimeCtx.DBQueries.RegisterNewCallable(ctx, queries.RegisterNewCallableParams{
					FastenID:    callable.ExternalID,
					PackageName: callable.PackageName,
					ClassName:   callable.ClassName,
					MethodName:  callable.MethodName,
				})
				if err != nil {
					return nil, fmt.Errorf("error when registering new callable: %w", err)
				}

				callableID = newCallableId
			} else {
				// Callable already exists, get its database ID for linking with the vulnerability
				callableID = existingCallableDatabaseIds[callable.ExternalID]
			}

			vulnerabilityCallableRelation[i] = queries.RegisterVulnerabilityCallableRelationsParams{
				CallableID:      callableID,
				VulnerabilityID: vulnerabilityID,
			}
		}

		// Link vulnerability with callables
		_, err := runtimeCtx.DBQueries.RegisterVulnerabilityCallableRelations(ctx, vulnerabilityCallableRelation)
		if err != nil {
			return nil, fmt.Errorf("error when linking callables to vulnerabilities: %w", err)
		}
	}

	return registeredVulnerabilityIds, nil
}

func mapDependenciesToVulnerabilityIDs(dependencyVulnerabilitiesMap map[maven.Coordinates][]vulnerabilities.Vulnerability, vulnerabilityIDs map[vulnerabilities.Vulnerability]int64) map[maven.Coordinates][]int64 {
	dependencyVulnerabilityIDMap := make(map[maven.Coordinates][]int64)
	for dependency, vulnerabilityList := range dependencyVulnerabilitiesMap {
		for _, vulnerability := range vulnerabilityList {
			dependencyVulnerabilityIDMap[dependency] = append(dependencyVulnerabilityIDMap[dependency], vulnerabilityIDs[vulnerability])
		}
	}
	return dependencyVulnerabilityIDMap
}

func FetchVulnerabilitiesAndCallables(ctx context.Context, runtimeCtx runtime.Context, dependencies []api.MavenCoordinates) (map[maven.Coordinates][]int64, error) {
	// Fetch vulnerabilities and vulnerable callables from FASTEN
	vulnerabilityCallablesMap, dependencyVulnerabilitiesMap := getVulnerabileCallablesForDependencies(ctx, runtimeCtx, dependencies)

	// Persist vulnerabilities and callables in the database
	registeredVulnerabilityIds, err := registerVulnerabilitiesAndCallables(ctx, runtimeCtx, vulnerabilityCallablesMap, dependencyVulnerabilitiesMap)
	if err != nil {
		return nil, fmt.Errorf("error when registering vulnerabilities and callables in the database: %w", err)
	}

	// Return vulnerability database identifiers to register with dependencies later
	dependencyVulnerabilityIDMap := mapDependenciesToVulnerabilityIDs(dependencyVulnerabilitiesMap, registeredVulnerabilityIds)

	return dependencyVulnerabilityIDMap, nil
}
