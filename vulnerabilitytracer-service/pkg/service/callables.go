package service

import (
	"context"
	"fmt"
	"sync"

	"vulnerabilitytracer-service/pkg/utils"

	"vulnerabilitytracer-service/db/generated/queries"
	"vulnerabilitytracer-service/pkg/callables"
	"vulnerabilitytracer-service/pkg/maven"
	"vulnerabilitytracer-service/pkg/server/runtime"
	"vulnerabilitytracer-service/pkg/vulnerabilities"

	mapset "github.com/deckarep/golang-set/v2"
	"github.com/sirupsen/logrus"
)

func getVulnerabileCallablesForDependencies(ctx context.Context, runtimeCtx runtime.Context,
	dependencies []maven.Coordinates,
) (
	map[vulnerabilities.Vulnerability][]callables.JavaCallable,
	map[maven.Coordinates][]vulnerabilities.Vulnerability,
) {
	type dependencyVulnerabilitiesAndCallables struct {
		Coordinates               maven.Coordinates
		VulnerabilityCallablesMap map[vulnerabilities.Vulnerability][]callables.JavaCallable
	}

	vulnerabilityCallablesMap := make(map[vulnerabilities.Vulnerability][]callables.JavaCallable)
	dependencyVulnerabilitiesMap := make(map[maven.Coordinates][]vulnerabilities.Vulnerability)

	// Query repository for vulnerabilities and callables in the dependencies
	waitGroup := new(sync.WaitGroup)
	succChan := make(chan dependencyVulnerabilitiesAndCallables)
	errChan := make(chan error)

	for _, dependency := range dependencies {
		coordinates := dependency
		waitGroup.Add(1)

		go func() {
			defer waitGroup.Done()

			vulnerabilityCallablesMap, err := runtimeCtx.FastenCallableRepository.GetVulnerableCallablesForDependency(ctx, coordinates)
			if err != nil {
				errChan <- err
			} else {
				succChan <- dependencyVulnerabilitiesAndCallables{
					Coordinates:               coordinates,
					VulnerabilityCallablesMap: vulnerabilityCallablesMap,
				}
			}
		}()
	}

	go func() {
		waitGroup.Wait()
		close(succChan)
		close(errChan)
	}()

	errorCount := 0
	succChanClosed := false
	errChanClosed := false

	for {
		select {
		case dvc, ok := <-succChan:
			if !ok {
				succChanClosed = true
			} else {
				// Save mapping between dependency and its vulnerabilities
				dependencyVulnerabilities := make([]vulnerabilities.Vulnerability, 0)
				for vulnerability := range dvc.VulnerabilityCallablesMap {
					dependencyVulnerabilities = append(dependencyVulnerabilities, vulnerability)
				}
				dependencyVulnerabilitiesMap[dvc.Coordinates] = append(dependencyVulnerabilitiesMap[dvc.Coordinates], dependencyVulnerabilities...)

				// Save mapping between vulnerabilities and their callables
				for vulnerability, callablesList := range dvc.VulnerabilityCallablesMap {
					vulnerabilityCallablesMap[vulnerability] = append(vulnerabilityCallablesMap[vulnerability], callablesList...)
				}
			}
		case err, ok := <-errChan:
			if !ok {
				errChanClosed = true
			} else {
				logrus.
					WithError(err).
					Error("error when fetching vulnerabilities and callables")
				errorCount++
			}
		}

		if succChanClosed && errChanClosed {
			break
		}
	}

	logrus.
		WithField("vulnerabilityCount", len(vulnerabilityCallablesMap)).
		WithField("dependencyCount", len(dependencyVulnerabilitiesMap)).
		WithField("errorCount", errorCount).
		Info("fetched vulnerabilities and callables from FASTEN")

	return vulnerabilityCallablesMap, dependencyVulnerabilitiesMap
}

// registerVulnerabilitiesAndCallables registers new vulnerabilities, callables and their links in the database.
// It returns the map of newly-added vulnerabilities to their database IDs
func registerVulnerabilitiesAndCallables(ctx context.Context, runtimeCtx runtime.Context,
	vulnerabilityCallablesMap map[vulnerabilities.Vulnerability][]callables.JavaCallable,
) (map[vulnerabilities.Vulnerability]int64, error) {
	// Fetch vulnerabilities and callables, currently in the database
	newVulnerabilityExternalIds := mapset.NewSet[string]()
	newCallableFastenIds := mapset.NewSet[string]()

	for vulnerability, callablesList := range vulnerabilityCallablesMap {
		newVulnerabilityExternalIds.Add(vulnerability.ExternalID)

		for _, c := range callablesList {
			newCallableFastenIds.Add(c.ExternalID)
		}
	}

	// Fetch existing vulnerabilities from the database
	registeredVulnerabilities, err := runtimeCtx.DBQueries.GetVulnerabilitiesForRegistration(ctx, newVulnerabilityExternalIds.ToSlice())
	if err != nil {
		return nil, fmt.Errorf("error when fetching registered vulnerabilities from database: %w", err)
	}

	existingVulnerabilityDatabaseIds := make(map[string]int64)
	existingVulnerabilityExternalIds := mapset.NewSet[string]()

	for _, v := range registeredVulnerabilities {
		existingVulnerabilityExternalIds.Add(v.ExternalID)
		existingVulnerabilityDatabaseIds[v.ExternalID] = v.ID
	}

	logrus.
		WithField("vulnerabilityCount", len(registeredVulnerabilities)).
		Debug("fetched already registered vulnerabilities from database")

	// Fetch existing callables from the database
	registeredCallables, err := runtimeCtx.DBQueries.GetCallablesForRegistration(ctx, newCallableFastenIds.ToSlice())
	if err != nil {
		return nil, fmt.Errorf("error when fetching registered callables from database: %w", err)
	}

	existingCallableDatabaseIds := make(map[string]int64)
	existingCallableFastenIds := mapset.NewSet[string]()

	for _, c := range registeredCallables {
		existingCallableFastenIds.Add(c.FastenID)
		existingCallableDatabaseIds[c.FastenID] = c.ID
	}

	logrus.
		WithField("callableCount", len(registeredCallables)).
		Debug("fetched already registered callables from database")

	// Persist new vulnerabilities and their callables in the database
	vulnerabilityExternalIdsToPersist := newVulnerabilityExternalIds.Difference(existingVulnerabilityExternalIds)
	callableFastenIdsToPersist := newCallableFastenIds.Difference(existingCallableFastenIds)

	logrus.
		WithField("newCallableCount", callableFastenIdsToPersist.Cardinality()).
		WithField("newVulnerabilityCount", vulnerabilityExternalIdsToPersist.Cardinality()).
		Info("registering new vulnerabilities and callables")

	registeredVulnerabilityIds := make(map[vulnerabilities.Vulnerability]int64)

	for vulnerability, callablesList := range vulnerabilityCallablesMap {
		var vulnerabilityID int64

		// Persist vulnerability if it does not exist
		if vulnerabilityExternalIdsToPersist.Contains(vulnerability.ExternalID) {
			// Vulnerability does not exist, register it
			newVulnerabilityID, err := runtimeCtx.DBQueries.RegisterNewVulnerability(ctx, queries.RegisterNewVulnerabilityParams{
				ExternalID: vulnerability.ExternalID,
				Severity:   string(vulnerability.Severity),
			})
			if err != nil {
				return nil, fmt.Errorf("error when registering new vulnerability: %w", err)
			}

			logrus.
				WithField("ID", newVulnerabilityID).
				WithField("externalID", vulnerability.ExternalID).
				Debug("registered new vulnerability")

			existingVulnerabilityExternalIds.Add(vulnerability.ExternalID)
			vulnerabilityExternalIdsToPersist.Remove(vulnerability.ExternalID)

			registeredVulnerabilityIds[vulnerability] = newVulnerabilityID
			existingVulnerabilityDatabaseIds[vulnerability.ExternalID] = newVulnerabilityID
			vulnerabilityID = newVulnerabilityID
		} else {
			// Vulnerability already exists, get its database ID for linking with the callables
			vulnerabilityID = existingVulnerabilityDatabaseIds[vulnerability.ExternalID]
		}

		vulnerabilityCallableLinks := make([]queries.RegisterVulnerabilityCallableRelationsParams, 0)

		// Persist callables if it does not exist
		for _, callable := range callablesList {
			if callableFastenIdsToPersist.Contains(callable.ExternalID) {
				// Callable does not exist, register it and bind it to the vulnerability
				newCallableID, err := runtimeCtx.DBQueries.RegisterNewCallable(ctx, queries.RegisterNewCallableParams{
					FastenID:    callable.ExternalID,
					PackageName: callable.PackageName,
					ClassName:   callable.ClassName,
					MethodName:  callable.MethodName,
				})
				if err != nil {
					return nil, fmt.Errorf("error when registering new callable: %w", err)
				}

				logrus.
					WithField("ID", newCallableID).
					WithField("externalID", callable.ExternalID).
					Debug("registered new callable")

				existingCallableFastenIds.Add(callable.ExternalID)
				callableFastenIdsToPersist.Remove(callable.ExternalID)

				vulnerabilityCallableLinks = append(vulnerabilityCallableLinks, queries.RegisterVulnerabilityCallableRelationsParams{
					CallableID:      newCallableID,
					VulnerabilityID: vulnerabilityID,
				})
				existingCallableDatabaseIds[callable.ExternalID] = newCallableID
			}
		}

		if len(vulnerabilityCallableLinks) > 0 {
			// Link vulnerability with callables
			count, err := runtimeCtx.DBQueries.RegisterVulnerabilityCallableRelations(ctx, vulnerabilityCallableLinks)
			if err != nil {
				return nil, fmt.Errorf("error when linking callables to vulnerabilities: %w", err)
			}

			logrus.
				WithField("linkCount", count).
				WithField("vulnerabilityID", vulnerabilityID).
				Debug("linked callables to vulnerability")
		}
	}

	logrus.
		WithField("newVulnerabilityCount", len(registeredVulnerabilityIds)).
		Info("finished registering vulnerabilities and callables")

	return registeredVulnerabilityIds, nil
}

func linkVulnerabilitiesToDependencies(ctx context.Context, runtimeCtx runtime.Context,
	newVulnerabilityIDs map[vulnerabilities.Vulnerability]int64,
	dependencyIDs map[maven.Coordinates]int64,
	dependencyVulnerabilityMap map[maven.Coordinates][]vulnerabilities.Vulnerability,
) error {
	if len(newVulnerabilityIDs) == 0 {
		logrus.Info("no new vulnerabilities to link to dependencies")
		return nil
	}

	params := make([]queries.RegisterDependencyVulnerabilitiesParams, 0)

	for dependency, dependencyVulnerabilities := range dependencyVulnerabilityMap {
		for _, vulnerability := range dependencyVulnerabilities {
			vulnerabilityID, exists := newVulnerabilityIDs[vulnerability]
			if exists {
				params = append(params, queries.RegisterDependencyVulnerabilitiesParams{
					DependencyID:    dependencyIDs[dependency],
					VulnerabilityID: vulnerabilityID,
				})
			}
		}
	}

	count, err := runtimeCtx.DBQueries.RegisterDependencyVulnerabilities(ctx, params)
	if err != nil {
		return fmt.Errorf("error when linking vulnerabilities to dependencies: %w", err)
	}

	logrus.
		WithField("linkCount", count).
		WithField("newVulnerabilityCount", len(newVulnerabilityIDs)).
		WithField("dependencyCount", len(dependencyIDs)).
		Info("linked vulnerabilities to dependencies")

	return nil
}

func RegisterVulnerabilitiesAndCallables(ctx context.Context, runtimeCtx runtime.Context,
	dependencyIDs map[maven.Coordinates]int64,
) ([]callables.JavaCallable, error) {
	dependencies := utils.GetMapKeys(dependencyIDs)

	// Fetch vulnerabilities and vulnerable callables from FASTEN
	vulnerabilityCallablesMap, dependencyVulnerabilitiesMap := getVulnerabileCallablesForDependencies(ctx, runtimeCtx, dependencies)

	// Persist vulnerabilities and callables in the database
	registeredVulnerabilityIds, err := registerVulnerabilitiesAndCallables(ctx, runtimeCtx, vulnerabilityCallablesMap)
	if err != nil {
		logrus.
			WithError(err).
			Error("error when registering vulnerabilities and callables in the database")

		return nil, fmt.Errorf("error when registering vulnerabilities and callables in the database: %w", err)
	}

	// Link vulnerabilities to dependencies
	err = linkVulnerabilitiesToDependencies(ctx, runtimeCtx, registeredVulnerabilityIds, dependencyIDs, dependencyVulnerabilitiesMap)
	if err != nil {
		logrus.
			WithError(err).
			Error("error when linking vulnerabilities to dependencies")

		return nil, fmt.Errorf("error when linking vulnerabilities to dependencies: %w", err)
	}

	// Collect and return callables of the dependencies
	vulnerableCallables := utils.GetFlattenedMapValues(vulnerabilityCallablesMap)

	return vulnerableCallables, nil
}
