package service

import (
	"context"
	"errors"
	"fmt"
	"strconv"

	"vulnerabilitytracer-service/api/generated/api"
	"vulnerabilitytracer-service/db/generated/queries"
	"vulnerabilitytracer-service/pkg/maven"
	"vulnerabilitytracer-service/pkg/server/runtime"

	"github.com/jackc/pgx/v5"
	"github.com/mitchellh/hashstructure/v2"
	"github.com/sirupsen/logrus"
)

func CheckServiceRegistration(ctx context.Context, runtimeCtx runtime.Context,
	serviceName string, dependencies []api.MavenCoordinates,
) (*int64, error) {
	dependenciesHash, err := computeDependenciesHash(dependencies)
	if err != nil {
		return nil, fmt.Errorf("error when computing dependencies hash: %w", err)
	}

	serviceID, err := runtimeCtx.DBQueries.GetServiceForRegistration(ctx, queries.GetServiceForRegistrationParams{
		Name:             serviceName,
		DependenciesHash: dependenciesHash,
	})
	if err != nil && errors.Is(err, pgx.ErrNoRows) {
		return nil, nil
	} else if err != nil {
		return nil, fmt.Errorf("error when fetching service from database: %w", err)
	}

	logrus.
		WithField("serviceID", serviceID).
		WithField("serviceName", serviceName).
		WithField("dependenciesHash", dependenciesHash).
		Info("service already registered")

	// Service exists
	return &serviceID, nil
}

func RegisterService(ctx context.Context, runtimeCtx runtime.Context,
	serviceName string, dependencies []api.MavenCoordinates,
) (int64, error) {
	dependenciesHash, err := computeDependenciesHash(dependencies)
	if err != nil {
		return 0, fmt.Errorf("error when computing dependencies hash: %w", err)
	}

	// Service does not exist yet, register it
	serviceID, err := runtimeCtx.DBQueries.RegisterNewService(ctx, queries.RegisterNewServiceParams{
		Name:             serviceName,
		DependenciesHash: dependenciesHash,
	})
	if err != nil {
		return 0, fmt.Errorf("error when saving service to database: %w", err)
	}

	logrus.
		WithField("serviceID", serviceID).
		WithField("serviceName", serviceName).
		WithField("dependenciesHash", dependenciesHash).
		Info("registered new service")

	return serviceID, nil
}

func RegisterServiceDependencies(ctx context.Context, runtimeCtx runtime.Context,
	serviceID int64, dependencies []api.MavenCoordinates,
) (map[maven.Coordinates]int64, error) {
	// Register new dependencies
	dependencyIDs := make(map[maven.Coordinates]int64)

	for _, d := range dependencies {
		id, err := runtimeCtx.DBQueries.RegisterNewDependency(ctx, queries.RegisterNewDependencyParams{
			GroupID:    d.GroupId,
			ArtifactID: d.ArtifactId,
			Version:    d.Version,
		})
		if err != nil {
			return nil, fmt.Errorf("error when registering new dependencies: %w", err)
		}

		logrus.
			WithField("dependencyID", id).
			Info("registered new dependency")

		dependencyIDs[maven.ConvertAPICoordinates(d)] = id
	}

	// Link dependencies to service
	serviceDependencies := make([]queries.RegisterServiceDependenciesParams, 0)
	for _, dependencyID := range dependencyIDs {
		serviceDependencies = append(serviceDependencies, queries.RegisterServiceDependenciesParams{
			ServiceID:    serviceID,
			DependencyID: dependencyID,
		})
	}

	registeredDependenciesCount, err := runtimeCtx.DBQueries.RegisterServiceDependencies(ctx, serviceDependencies)
	if err != nil {
		return nil, fmt.Errorf("error when registering new dependencies for the service: %w", err)
	}

	logrus.
		WithField("serviceID", serviceID).
		WithField("dependencyCount", registeredDependenciesCount).
		Info("registered dependencies for service")

	return dependencyIDs, nil
}

func computeDependenciesHash(dependencies []api.MavenCoordinates) (string, error) {
	hash, err := hashstructure.Hash(dependencies, hashstructure.FormatV2, nil)
	if err != nil {
		return "", err
	}

	return strconv.FormatUint(hash, 16), nil
}
