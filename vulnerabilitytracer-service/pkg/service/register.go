package service

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"

	"vulnerabilitytracer/internal/runtime"

	"vulnerabilitytracer/pkg/callables"

	"vulnerabilitytracer/api/generated/api"
	"vulnerabilitytracer/db/generated/queries"
	"vulnerabilitytracer/pkg/maven"

	"github.com/jackc/pgx/v5"
	"github.com/mitchellh/hashstructure/v2"
	"github.com/sirupsen/logrus"
)

var ErrRegisteringDependencies = errors.New("error when registering dependencies")

func CheckServiceRegistration(ctx context.Context, runtimeCtx runtime.Context,
	serviceName string, dependencies []api.MavenCoordinates,
) (*int64, error) {
	dependenciesHash, err := computeDependenciesHash(dependencies)
	if err != nil {
		return nil, fmt.Errorf("error when computing dependencies hash: %w", err)
	}

	serviceID, err := runtimeCtx.DBQueries.GetServiceForRegistration(ctx, queries.GetServiceForRegistrationParams{
		Name:             serviceName,
		DependenciesHash: dependenciesHash,
	})
	if err != nil && errors.Is(err, pgx.ErrNoRows) {
		return nil, nil
	} else if err != nil {
		return nil, fmt.Errorf("error when fetching service from database: %w", err)
	}

	logrus.
		WithField("serviceID", serviceID).
		WithField("serviceName", serviceName).
		WithField("dependenciesHash", dependenciesHash).
		Info("service already registered")

	// Service exists
	return &serviceID, nil
}

func RegisterService(ctx context.Context, runtimeCtx runtime.Context,
	serviceName string, dependencies []api.MavenCoordinates,
) (int64, error) {
	dependenciesHash, err := computeDependenciesHash(dependencies)
	if err != nil {
		return 0, fmt.Errorf("error when computing dependencies hash: %w", err)
	}

	// Service does not exist yet, register it
	serviceID, err := runtimeCtx.DBQueries.RegisterNewService(ctx, queries.RegisterNewServiceParams{
		Name:             serviceName,
		DependenciesHash: dependenciesHash,
	})
	if err != nil {
		return 0, fmt.Errorf("error when saving service to database: %w", err)
	}

	logrus.
		WithField("serviceID", serviceID).
		WithField("serviceName", serviceName).
		WithField("dependenciesHash", dependenciesHash).
		Info("registered new service")

	return serviceID, nil
}

func registerDependency(ctx context.Context, runtimeCtx runtime.Context,
	dependency maven.Coordinates,
) (int64, error) {
	// Check if FASTEN has processed this dependency before
	processingStatus, err := runtimeCtx.FastenCallableRepository.GetDependencyProcessingStatus(ctx, dependency)
	if err != nil {
		return 0, fmt.Errorf("error when checking dependency processing status: %w", err)
	}

	fastenProcessed := processingStatus == callables.Processed

	dependencyID, err := runtimeCtx.DBQueries.RegisterNewDependency(ctx, queries.RegisterNewDependencyParams{
		GroupID:         dependency.GroupID,
		ArtifactID:      dependency.ArtifactID,
		Version:         dependency.Version,
		FastenProcessed: fastenProcessed,
	})
	if err != nil {
		return 0, fmt.Errorf("error when registering new dependencies: %w", err)
	}

	logrus.
		WithField("dependencyID", dependencyID).
		WithField("groupID", dependency.GroupID).
		WithField("artifactID", dependency.ArtifactID).
		WithField("version", dependency.Version).
		WithField("fastenProcessed", fastenProcessed).
		Info("registered new dependency")

	return dependencyID, nil
}

func RegisterServiceDependencies(ctx context.Context, runtimeCtx runtime.Context,
	serviceID int64, dependencies []api.MavenCoordinates,
) (map[maven.Coordinates]int64, error) {
	type dependencyAndId struct {
		Coordinates maven.Coordinates
		ID          int64
	}

	// Look for already registered dependencies
	registeredDependencies := make([]dependencyAndId, 0)
	dependenciesToRegister := make([]api.MavenCoordinates, 0)
	for _, d := range dependencies {
		dependencyID, err := runtimeCtx.DBQueries.GetRegisteredDependencyId(ctx, queries.GetRegisteredDependencyIdParams{
			GroupID:    d.GroupId,
			ArtifactID: d.ArtifactId,
			Version:    d.Version,
		})
		if err == nil {
			registeredDependencies = append(registeredDependencies, dependencyAndId{
				Coordinates: maven.ConvertAPICoordinates(d),
				ID:          dependencyID,
			})
		} else if err != nil && errors.Is(err, pgx.ErrNoRows) {
			dependenciesToRegister = append(dependenciesToRegister, d)
		} else {
			return nil, fmt.Errorf("error when fetching registered dependency: %w", err)
		}
	}

	logrus.
		WithField("registeredCount", len(registeredDependencies)).
		WithField("toRegisterCount", len(dependenciesToRegister)).
		Info("finished checking for already registered dependencies")

	// Register new dependencies
	waitGroup := new(sync.WaitGroup)
	succChan := make(chan dependencyAndId)
	errChan := make(chan error)

	for _, d := range dependenciesToRegister {
		coordinates := maven.ConvertAPICoordinates(d)

		waitGroup.Add(1)

		go func() {
			defer waitGroup.Done()

			dependencyID, err := registerDependency(ctx, runtimeCtx, coordinates)
			if err != nil {
				errChan <- err
			} else {
				succChan <- dependencyAndId{
					Coordinates: coordinates,
					ID:          dependencyID,
				}
			}
		}()
	}

	dependencyIDs := make(map[maven.Coordinates]int64)

	go func() {
		waitGroup.Wait()
		close(succChan)
		close(errChan)
	}()

	errorCount := 0
	succChanClosed := false
	errChanClosed := false

	for {
		select {
		case dependencyAndId, ok := <-succChan:
			if !ok {
				succChanClosed = true
			} else {
				dependencyIDs[dependencyAndId.Coordinates] = dependencyAndId.ID
			}
		case err, ok := <-errChan:
			if !ok {
				errChanClosed = true
			} else {
				logrus.
					WithError(err).
					Error("error when registering dependency")
				errorCount++
			}
		}

		if succChanClosed && errChanClosed {
			break
		}
	}

	logrus.
		WithField("success", len(dependencyIDs)).
		WithField("errorCount", errorCount).
		Info("finished registering dependencies")

	if errorCount > 0 {
		return nil, ErrRegisteringDependencies
	}

	// Add the previously registered dependencies to the map
	for _, dependencyAndId := range registeredDependencies {
		dependencyIDs[dependencyAndId.Coordinates] = dependencyAndId.ID
	}

	// Link dependencies to service
	serviceDependencies := make([]queries.RegisterServiceDependenciesParams, 0)
	for _, dependencyID := range dependencyIDs {
		serviceDependencies = append(serviceDependencies, queries.RegisterServiceDependenciesParams{
			ServiceID:    serviceID,
			DependencyID: dependencyID,
		})
	}

	registeredDependenciesCount, err := runtimeCtx.DBQueries.RegisterServiceDependencies(ctx, serviceDependencies)
	if err != nil {
		return nil, fmt.Errorf("error when registering new dependencies for the service: %w", err)
	}

	logrus.
		WithField("serviceID", serviceID).
		WithField("dependencyCount", registeredDependenciesCount).
		Info("registered dependencies for service")

	return dependencyIDs, nil
}

func computeDependenciesHash(dependencies []api.MavenCoordinates) (string, error) {
	hash, err := hashstructure.Hash(dependencies, hashstructure.FormatV2, nil)
	if err != nil {
		return "", err
	}

	return strconv.FormatUint(hash, 16), nil
}
