package service

import (
	"context"
	"errors"
	"fmt"
	"strconv"

	"vulnerabilitytracer-service/api/generated/api"
	"vulnerabilitytracer-service/db/generated/queries"
	"vulnerabilitytracer-service/pkg/server/runtime"

	"github.com/jackc/pgx/v5"
	"github.com/mitchellh/hashstructure/v2"
	"github.com/sirupsen/logrus"
)

func CheckServiceRegistration(ctx context.Context, runtimeCtx runtime.Context, serviceName string, dependencies []api.MavenCoordinates) (*int64, error) {
	dependenciesHash, err := computeDependenciesHash(dependencies)
	if err != nil {
		return nil, fmt.Errorf("error when computing dependencies hash: %w", err)
	}

	serviceID, err := runtimeCtx.DBQueries.GetServiceForRegistration(ctx, queries.GetServiceForRegistrationParams{
		Name:             serviceName,
		DependenciesHash: dependenciesHash,
	})
	if err != nil && errors.Is(err, pgx.ErrNoRows) {
		return nil, nil
	} else if err != nil {
		return nil, fmt.Errorf("error when fetching service from database: %w", err)
	}

	logrus.
		WithField("serviceID", serviceID).
		WithField("serviceName", serviceName).
		WithField("dependenciesHash", dependenciesHash).
		Info("service already registered")

	// Service exists
	return &serviceID, nil
}

func RegisterService(ctx context.Context, runtimeCtx runtime.Context, serviceName string, dependencies []api.MavenCoordinates) (int64, error) {
	dependenciesHash, err := computeDependenciesHash(dependencies)
	if err != nil {
		return 0, fmt.Errorf("error when computing dependencies hash: %w", err)
	}

	// Service does not exist yet, register it
	serviceID, err := runtimeCtx.DBQueries.RegisterNewService(ctx, queries.RegisterNewServiceParams{
		Name:             serviceName,
		DependenciesHash: dependenciesHash,
	})
	if err != nil {
		return 0, fmt.Errorf("error when saving service to database: %w", err)
	}

	logrus.
		WithField("serviceID", serviceID).
		WithField("serviceName", serviceName).
		WithField("dependenciesHash", dependenciesHash).
		Info("registered new service")

	return serviceID, nil
}

func RegisterServiceDependencies(ctx context.Context, runtimeCtx runtime.Context, serviceId int64, dependencies []api.MavenCoordinates) error {
	// Register new dependencies
	dependencyIds := make([]int64, len(dependencies))

	for i, d := range dependencies {
		id, err := runtimeCtx.DBQueries.RegisterNewDependency(ctx, queries.RegisterNewDependencyParams{
			GroupID:    d.GroupId,
			ArtifactID: d.ArtifactId,
			Version:    d.Version,
		})
		if err != nil {
			return fmt.Errorf("error when registering new dependencies: %w", err)
		}

		logrus.
			WithField("dependencyID", id).
			Info("registered new dependency")

		dependencyIds[i] = id
	}

	serviceDependencies := make([]queries.RegisterServiceDependenciesParams, len(dependencyIds))
	for i, d := range dependencyIds {
		serviceDependencies[i] = queries.RegisterServiceDependenciesParams{
			ServiceID:    serviceId,
			DependencyID: d,
		}
	}

	// Register new dependencies
	registeredDependenciesCount, err := runtimeCtx.DBQueries.RegisterServiceDependencies(ctx, serviceDependencies)
	if err != nil {
		return fmt.Errorf("error when registering new dependencies for the service: %w", err)
	}

	logrus.
		WithField("serviceID", serviceId).
		WithField("dependencyCount", registeredDependenciesCount).
		Info("registered dependencies for service")

	return nil
}

func computeDependenciesHash(dependencies []api.MavenCoordinates) (string, error) {
	hash, err := hashstructure.Hash(dependencies, hashstructure.FormatV2, nil)
	if err != nil {
		return "", err
	}
	return strconv.FormatUint(hash, 16), nil
}
