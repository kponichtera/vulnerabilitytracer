package callablesrepository

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"

	"vulnerabilitytracer-service/api/generated/fastenapi"
	"vulnerabilitytracer-service/pkg/fasten"

	mapset "github.com/deckarep/golang-set/v2"
	"github.com/sirupsen/logrus"
	"golang.org/x/sync/semaphore"
)

var ErrMissingCallableQualityMetadata = errors.New("missing callable quality metadata")

type FastenJavaCallableRepository struct {
	apiClient          *fastenapi.ClientWithResponses
	apiClientSemaphore *semaphore.Weighted
}

func useFastenApiClient[R interface{}](ctx context.Context, repository *FastenJavaCallableRepository,
	apiConsumeFunc func(*fastenapi.ClientWithResponses, chan<- R, chan<- error),
) (<-chan R, <-chan error, error) {
	err := repository.apiClientSemaphore.Acquire(ctx, 1)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to acquire FASTEN API semaphore: %w", err)
	}

	successChan := make(chan R)
	errorChan := make(chan error)

	go func() {
		defer repository.apiClientSemaphore.Release(1)
		apiConsumeFunc(repository.apiClient, successChan, errorChan)
	}()

	return successChan, errorChan, nil
}

func NewFastenJavaCallableRepository(apiClient *fastenapi.ClientWithResponses) *FastenJavaCallableRepository {
	return &FastenJavaCallableRepository{
		apiClient:          apiClient,
		apiClientSemaphore: semaphore.NewWeighted(10), // TODO: Get from config
	}
}

func (r *FastenJavaCallableRepository) getVulnerabilitiesForDependency(ctx context.Context, coordinates MavenCoordinates) ([]fastenapi.PackageVulnerability, error) {
	// Get vulnerabilities for the dependency
	vulnerabilitySuccChan, errChan, err := useFastenApiClient(ctx, r,
		func(apiClient *fastenapi.ClientWithResponses, succChan chan<- []fastenapi.PackageVulnerability, errChan chan<- error) {
			vulnerabilities, err := fasten.GetSimpleVulnerabilities(ctx, apiClient, coordinates.GroupID, coordinates.ArtifactID, coordinates.Version)
			if err != nil {
				errChan <- fmt.Errorf("error when getting vulnerabilities for dependency: %w", err)
				close(succChan)
			}
			succChan <- vulnerabilities
			close(errChan)
		})
	if err != nil {
		return nil, fmt.Errorf("error when using FASTEN API client: %w", err)
	}

	if err := <-errChan; err != nil {
		return nil, fmt.Errorf("error in FASTEN API client goroutine: %w", err)
	}

	vulnerabilities := <-vulnerabilitySuccChan

	logrus.
		WithField("artifactID", coordinates.ArtifactID).
		WithField("groupID", coordinates.GroupID).
		WithField("version", coordinates.Version).
		WithField("vulnerabilityCount", len(vulnerabilities)).
		Info("finished collecting vulnerabilities for dependency")

	return vulnerabilities, nil
}

func (r *FastenJavaCallableRepository) getCallableIdsForVulnerabilities(ctx context.Context, vulnerabilities []fastenapi.PackageVulnerability) ([]int, error) {
	waitGroup := new(sync.WaitGroup)
	globalCallablesMapChan := make(chan map[string]string)
	globalErrChan := make(chan error)

	for _, vulnerability := range vulnerabilities {
		vulnerabilityExternalID := vulnerability.ExternalId

		waitGroup.Add(1)
		go func() {
			defer waitGroup.Done()

			succChan, errChan, err := useFastenApiClient(ctx, r,
				func(apiClient *fastenapi.ClientWithResponses, succChan chan<- map[string]string, errChan chan<- error) {
					callablesMap, err := fasten.GetVulnerabilityCallables(ctx, apiClient, vulnerabilityExternalID)
					if err != nil {
						errChan <- fmt.Errorf("error when getting callables for vulnerability: %w", err)
						close(succChan)
					}
					succChan <- callablesMap
					close(errChan)
				})
			if err != nil {
				logrus.WithError(err).Error("error when using FASTEN API client")
				globalErrChan <- err
			}

			if err := <-errChan; err != nil {
				logrus.WithError(err).Error("error in FASTEN API client goroutine")
				globalErrChan <- err
			}

			globalCallablesMapChan <- <-succChan
		}()
	}

	waitGroup.Wait()

	logrus.
		WithField("successCount", len(globalCallablesMapChan)).
		WithField("errorCount", len(globalErrChan)).
		Info("finished waiting for callable ID collection")

	callableIds := mapset.NewSet[int]()
	for callableIDMap := range globalCallablesMapChan {
		for key := range callableIDMap {
			callableID, err := strconv.Atoi(key)
			if err != nil {
				logrus.WithError(err).Error("error when converting callable ID to integer")
			} else {
				callableIds.Add(callableID)
			}
		}
	}

	callableIdsSlice := callableIds.ToSlice()

	logrus.
		WithField("collectedIdCount", len(callableIdsSlice)).
		Info("finished collecting callable IDs")

	return callableIdsSlice, nil
}

func (r *FastenJavaCallableRepository) getCallables(ctx context.Context, callableIds []int) ([]JavaCallable, error) {
	callablesSuccChan, errChan, err := useFastenApiClient(ctx, r,
		func(apiClient *fastenapi.ClientWithResponses, succChan chan<- map[string]fastenapi.Callable, errChan chan<- error) {
			callables, err := fasten.GetCallables(ctx, apiClient, callableIds)
			if err != nil {
				errChan <- fmt.Errorf("error when getting callables: %w", err)
				close(succChan)
			}
			succChan <- callables
			close(errChan)
		})
	if err != nil {
		return nil, fmt.Errorf("error when using FASTEN API client: %w", err)
	}

	if err := <-errChan; err != nil {
		return nil, fmt.Errorf("error in FASTEN API client goroutine: %w", err)
	}

	callablesMap := <-callablesSuccChan

	callables, parseErrors := parseFastenCallables(callablesMap)

	logrus.
		WithField("successCount", len(callables)).
		WithField("errorCount", len(parseErrors)).
		Info("finished parsing FASTEN callables")

	return callables, nil
}

func parseFastenCallables(callablesMap map[string]fastenapi.Callable) ([]JavaCallable, []error) {
	callables := make([]JavaCallable, 0)
	parseErrors := make([]error, 0)

	for callableId, callable := range callablesMap {
		if callable.Metadata.Quality == nil {
			logrus.
				WithField("callableID", callableId).
				Error("missing callable quality metadata")
			parseErrors = append(parseErrors, ErrMissingCallableQualityMetadata)
			continue
		}

		packageName, err := fasten.JavaPackageFromFastenURI(callable.FastenUri)
		if err != nil {
			logrus.
				WithField("callableID", callableId).
				WithError(err).
				Error("problem with parsing package name from FASTEN URI")

			parseErrors = append(parseErrors, err)
			continue
		}

		classAndMethodName, err := fasten.ClassAndMethodNameFromCallableName(callable.Metadata.Quality.CallableName)
		if err != nil {
			logrus.
				WithField("callableID", callableId).
				WithError(err)

			parseErrors = append(parseErrors, err)
			continue
		}

		callable := JavaCallable{
			Id:          callable.FastenUri,
			PackageName: packageName,
			ClassName:   classAndMethodName.ClassName,
			MethodName:  classAndMethodName.MethodName,
		}

		callables = append(callables, callable)
	}

	return callables, parseErrors
}

func (r *FastenJavaCallableRepository) GetCallablesForDependency(ctx context.Context, coordinates MavenCoordinates) ([]JavaCallable, error) {
	vulnerabilities, err := r.getVulnerabilitiesForDependency(ctx, coordinates)
	if err != nil {
		return nil, fmt.Errorf("error when fetching vulnerabilities for dependency: %w", err)
	}

	if len(vulnerabilities) == 0 {
		return nil, nil
	}

	callableIds, err := r.getCallableIdsForVulnerabilities(ctx, vulnerabilities)
	if err != nil {
		return nil, fmt.Errorf("error when fetching callables for vulnerabilities: %w", err)
	}

	callables, err := r.getCallables(ctx, callableIds)
	if err != nil {
		return nil, fmt.Errorf("error when fetching callables: %w", err)
	}

	return callables, nil
}
