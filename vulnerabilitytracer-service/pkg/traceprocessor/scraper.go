package traceprocessor

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"time"

	"vulnerabilitytracer/pkg/mitigationstrategies"
	"vulnerabilitytracer/pkg/tracegraph"
	"vulnerabilitytracer/pkg/vulnerabilities"

	"github.com/dominikbraun/graph"

	"vulnerabilitytracer/pkg/utils"

	"github.com/jackc/pgx/v5"

	"vulnerabilitytracer/api/generated/tempoquerierapi"
	"vulnerabilitytracer/db/generated/queries"
	"vulnerabilitytracer/pkg/tempo"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/sirupsen/logrus"
)

var (
	ErrMissingAttributeValue = errors.New("attribute value is missing")
	ErrMissingServiceName    = errors.New("batch has no service name attribute")
	ErrIncompleteEvent       = errors.New("event attributes are incomplete, maybe agent is not up to date")
)

func scrape(ctx context.Context, runtimeCtx *Context) error {
	// Determine the oldest time, for which the traces are meant to be collected
	fromTime := time.Now().Add(-runtimeCtx.TraceMaxAge)

	logrus.Info("running scraper")

	// Get traces to scrape
	tracesToScrape, err := getTracesToScrape(ctx, runtimeCtx, fromTime)
	if err != nil {
		return fmt.Errorf("error when getting traces to scrape: %w", err)
	}

	if len(tracesToScrape) == 0 {
		logrus.Info("no traces to scrape")

		return nil
	}

	logrus.Debugf("fetched %d traces from database", len(tracesToScrape))

	// Query Tempo for traces
	tempoTraces := queryTempoTraces(ctx, runtimeCtx, tracesToScrape)
	tempoTraceIDs := utils.GetMapKeys(tempoTraces)

	logrus.Debugf("fetched %d traces from Tempo", len(tempoTraces))

	// Start transaction to persist events and mark traces as scraped in one go
	tx, err := runtimeCtx.DBPool.BeginTx(ctx, pgx.TxOptions{
		IsoLevel: pgx.ReadUncommitted,
	})
	if err != nil {
		return fmt.Errorf("error when starting transaction: %w", err)
	}
	defer tx.Commit(ctx)

	// Extract graphs and events from traces and persist them
	err = processTraces(ctx, runtimeCtx, tx, tempoTraces)
	if err != nil {
		tx.Rollback(ctx)
		return fmt.Errorf("error when processing traces: %w", err)
	}

	// Mark traces as scraped
	err = markTracesAsScraped(ctx, runtimeCtx, tx, tempoTraceIDs)
	if err != nil {
		tx.Rollback(ctx)
		return fmt.Errorf("error when marking traces as scraped: %w", err)
	}

	logrus.
		WithField("traceCount", len(tempoTraceIDs)).
		Info("marked traces as scraped")

	// Count remaining traces
	unscrapedTraceCount, err := runtimeCtx.DBQueries.CountUnscrapedTraces(ctx, pgtype.Timestamptz{
		Time:  fromTime,
		Valid: true,
	})
	if err != nil {
		tx.Rollback(ctx)
		return fmt.Errorf("error when counting unscraped traces: %w", err)
	}

	logrus.
		WithField("scrapedTraceCount", len(tempoTraceIDs)).
		WithField("remainingTraceCount", unscrapedTraceCount).
		Info("scraper run finished")

	return nil
}

type traceToScrape struct {
	ID      int64
	TempoID string
	Time    time.Time
}

func getTracesToScrape(ctx context.Context, runtimeCtx *Context,
	from time.Time,
) ([]traceToScrape, error) {
	result, err := runtimeCtx.DBQueries.GetTracesToScrape(ctx, queries.GetTracesToScrapeParams{
		Fromtime: pgtype.Timestamptz{
			Time:  from,
			Valid: true,
		},
		BatchSize: int32(runtimeCtx.TraceBatchSize),
	})
	if err != nil {
		return nil, fmt.Errorf("error when querying database for traces to scrape: %w", err)
	}

	tracesToScrape := make([]traceToScrape, len(result))
	for i, trace := range result {
		tracesToScrape[i] = traceToScrape{
			ID:      trace.ID,
			TempoID: trace.TempoID,
			Time:    trace.Time.Time,
		}
	}

	return tracesToScrape, nil
}

func queryTempoTraces(ctx context.Context, runtimeCtx *Context,
	tracesToScrape []traceToScrape,
) map[int64]tempoquerierapi.TraceQueryResponsePayload {
	traces := make(map[int64]tempoquerierapi.TraceQueryResponsePayload)
	traceCount := 0
	errorCount := 0

	for _, trace := range tracesToScrape {
		fromTime := trace.Time.Add(-1 * time.Minute)
		toTime := trace.Time.Add(1 * time.Minute)

		result, err := tempo.TraceQuery(ctx, runtimeCtx.TempoQuerierClient, trace.TempoID, fromTime, toTime)
		if err != nil {
			logrus.WithError(err).Error("failed to search for service traces")
			errorCount++
		} else {
			traces[trace.ID] = result
			traceCount++
		}
	}

	logrus.
		WithField("traceCount", traceCount).
		WithField("errorCount", errorCount).
		Info("finished querying for Tempo traces")

	return traces
}

func markTracesAsScraped(ctx context.Context, runtimeCtx *Context, tx pgx.Tx,
	traceIDs []int64,
) error {
	err := runtimeCtx.DBQueries.WithTx(tx).SetTracesAsScraped(ctx, traceIDs)
	if err != nil {
		return fmt.Errorf("error when marking traces as scraped: %w", err)
	}
	return nil
}

type scrapedEvent struct {
	VulnerabilityExternalID string
	CallableFastenID        string
	TriggerTime             time.Time
	MitigationStrategy      string
	Severity                string
}

const (
	serviceNameBatchAttributeName   = "service.name"
	vulnerabilityTriggeredEventName = "vulnerability-triggered"
)

func extractBatchServiceName(batch tempoquerierapi.TraceQueryResponseBatch) (string, error) {
	for _, attribute := range batch.Resource.Attributes {
		if attribute.Key == serviceNameBatchAttributeName {
			if attribute.Value.StringValue == nil {
				return "", fmt.Errorf("error when extracting service name from batch: %w", ErrMissingAttributeValue)
			}
			return *attribute.Value.StringValue, nil
		}
	}

	return "", ErrMissingServiceName
}

type scrapedSpan struct {
	serviceName   string
	spanID        string
	parentSpanID  *string
	scrapedEvents []scrapedEvent
}

func scrapeSpansAndEvents(trace tempoquerierapi.TraceQueryResponsePayload) ([]scrapedSpan, error) {
	spans := make([]scrapedSpan, 0)

	for _, batch := range trace.Batches {
		serviceName, err := extractBatchServiceName(batch)
		if err != nil {
			return nil, fmt.Errorf("error when extracting service name from batch: %w", err)
		}

		for _, scopeSpan := range batch.ScopeSpans {
			for _, span := range scopeSpan.Spans {

				events := make([]scrapedEvent, 0)

				// Extract span's events
				if span.Events != nil {
					for _, event := range *span.Events {
						if event.Name != vulnerabilityTriggeredEventName {
							// Not a vulnerability trigger event, continue to the next one
							continue
						}

						extractedEvent, err := extractEvent(event)
						if err != nil {
							return nil, fmt.Errorf("error when extracting event: %w", err)
						}
						events = append(events, *extractedEvent)
					}
				}

				spans = append(spans, scrapedSpan{
					serviceName:   serviceName,
					spanID:        span.SpanId,
					parentSpanID:  span.ParentSpanId,
					scrapedEvents: events,
				})
			}
		}
	}

	return spans, nil
}

func buildTraceGraph(trace tempoquerierapi.TraceQueryResponsePayload) (tracegraph.Graph, error) {
	graph := tracegraph.New()

	spans, err := scrapeSpansAndEvents(trace)
	if err != nil {
		return nil, fmt.Errorf("error when scraping spans and events: %w", err)
	}

	// Add vertices to the graph
	for _, span := range spans {
		events := make([]tracegraph.Event, 0)
		for _, event := range span.scrapedEvents {
			events = append(events, tracegraph.Event{
				VulnerabilityExternalID: event.VulnerabilityExternalID,
				CallableFastenID:        event.CallableFastenID,
				TriggerTime:             event.TriggerTime,
				MitigationStrategy:      event.MitigationStrategy,
				Severity:                event.Severity,
			})
		}

		node := tracegraph.Node{
			ID:          span.spanID,
			ServiceName: span.serviceName,
			Events:      events,
		}
		err := graph.AddVertex(node)
		if err != nil {
			return nil, fmt.Errorf("error when adding vertex to graph: %w", err)
		}
	}

	// Add edges to the graph
	for _, span := range spans {
		if span.parentSpanID != nil {
			err := graph.AddEdge(*span.parentSpanID, span.spanID)
			if err != nil {
				return nil, fmt.Errorf("error when adding edge to graph: %w", err)
			}
		}
	}

	// Reduce the graph
	reducedGraph, err := tracegraph.Reduce(graph)
	if err != nil {
		return nil, fmt.Errorf("error when reducing graph: %w", err)
	}

	return reducedGraph, nil
}

func persistTraceGraph(ctx context.Context, runtimeCtx *Context, tx pgx.Tx,
	traceID int64, traceGraph tracegraph.Graph,
) error {
	adjacencyMap, err := traceGraph.AdjacencyMap()
	if err != nil {
		return fmt.Errorf("error when getting adjacency map: %w", err)
	}

	// Persist nodes
	nodeInsertParams := make([]queries.InsertTraceGraphNodesParams, 0)

	for nodeID := range adjacencyMap {
		node, err := traceGraph.Vertex(nodeID)
		if err != nil {
			return fmt.Errorf("error when getting vertex from graph: %w", err)
		}

		nodeInsertParams = append(nodeInsertParams, queries.InsertTraceGraphNodesParams{
			TraceID:     traceID,
			SpanID:      node.ID,
			ServiceName: node.ServiceName,
		})
	}

	persistedNodeCount, err := runtimeCtx.DBQueries.WithTx(tx).InsertTraceGraphNodes(ctx, nodeInsertParams)
	if err != nil {
		return fmt.Errorf("error when persisting graph nodes for trace %d: %w", traceID, err)
	}

	logrus.
		WithField("traceID", traceID).
		WithField("nodeCount", persistedNodeCount).
		Debug("trace graph nodes persisted in the database")

	// Persist edges
	edgeInsertParams := make([]queries.InsertTraceGraphEdgesParams, 0)

	for sourceID, successors := range adjacencyMap {
		for targetID := range successors {
			edgeInsertParams = append(edgeInsertParams, queries.InsertTraceGraphEdgesParams{
				SourceTraceID: traceID,
				SourceSpanID:  sourceID,
				TargetTraceID: traceID,
				TargetSpanID:  targetID,
			})
		}
	}

	persistedEdgeCount, err := runtimeCtx.DBQueries.WithTx(tx).InsertTraceGraphEdges(ctx, edgeInsertParams)
	if err != nil {
		return fmt.Errorf("error when persisting graph edges for trace %d: %w", traceID, err)
	}

	logrus.
		WithField("traceID", traceID).
		WithField("edgeCount", persistedEdgeCount).
		Debug("trace graph edges persisted in the database")

	return nil
}

func persistEvents(ctx context.Context, runtimeCtx *Context, tx pgx.Tx,
	traceID int64, traceGraph tracegraph.Graph,
) error {
	type eventToPersist struct {
		SpanID                  string
		ServiceName             string
		VulnerabilityExternalID string
		CallableFastenID        string
		TriggerTime             time.Time
		MitigationStrategy      queries.ServiceMitigationStrategyType
		Severity                queries.VulnerabilitiesSeverity
	}

	rootID, err := tracegraph.FindRoot(traceGraph)
	if err != nil {
		return fmt.Errorf("error when finding root in trace graph: %w", err)
	}

	eventsToPersist := make([]eventToPersist, 0)

	err = graph.BFS(traceGraph, *rootID, func(nodeID tracegraph.NodeID) bool {
		node, _ := traceGraph.Vertex(nodeID)

		for _, event := range node.Events {
			eventsToPersist = append(eventsToPersist, eventToPersist{
				SpanID:                  node.ID,
				ServiceName:             node.ServiceName,
				VulnerabilityExternalID: event.VulnerabilityExternalID,
				CallableFastenID:        event.CallableFastenID,
				TriggerTime:             event.TriggerTime,
				MitigationStrategy:      mitigationstrategies.ConvertStringToDatabaseEnum(&event.MitigationStrategy),
				Severity:                vulnerabilities.ConvertStringToDatabaseEnum(event.Severity),
			})
		}

		return false
	})

	for _, event := range eventsToPersist {
		err := runtimeCtx.DBQueries.WithTx(tx).InsertEvent(ctx, queries.InsertEventParams{
			TraceID:                 traceID,
			SpanID:                  event.SpanID,
			ServiceName:             event.ServiceName,
			VulnerabilityExternalID: event.VulnerabilityExternalID,
			CallableFastenID:        event.CallableFastenID,
			Time: pgtype.Timestamptz{
				Time:  event.TriggerTime,
				Valid: true,
			},
			MitigationStrategy: event.MitigationStrategy,
			Severity:           event.Severity,
		})
		if err != nil {
			return fmt.Errorf("error when persisting event for trace %d: %w", traceID, err)
		}
	}

	if len(eventsToPersist) > 0 {
		logrus.
			WithField("traceID", traceID).
			WithField("eventCount", len(eventsToPersist)).
			Info("events persisted in the database")
	}

	return nil
}

// processTraces builds trace graphs with events and persists them in the database
func processTraces(ctx context.Context, runtimeCtx *Context, tx pgx.Tx,
	traces map[int64]tempoquerierapi.TraceQueryResponsePayload,
) error {
	successCount := 0
	errorCount := 0

	// Extract and persist events
	for traceId, trace := range traces {
		graph, err := buildTraceGraph(trace)
		if err != nil {
			errorCount++
			logrus.
				WithError(err).
				WithField("traceID", traceId).
				Warn("trace graph could not be built, trace will be skipped")

			continue
		}

		err = persistTraceGraph(ctx, runtimeCtx, tx, traceId, graph)
		if err != nil {
			return fmt.Errorf("error when persisting trace graph for trace %d: %w", traceId, err)
		}

		successCount++

		err = persistEvents(ctx, runtimeCtx, tx, traceId, graph)
		if err != nil {
			return fmt.Errorf("error when persisting trace graph for trace %d: %w", traceId, err)
		}
	}

	logrus.
		WithField("successCount", successCount).
		WithField("errorCount", errorCount).
		Info("finished processing traces")

	return nil
}

const (
	vulnerabilityExternalIdEventAttributeName = "externalId"
	callableFastenIdEventAttributeName        = "fastenId"
	mitigationStrategyEventAttributeName      = "mitigationStrategy"
	severityEventAttributeName                = "severity"
)

func extractEvent(event tempoquerierapi.SpanEvent) (*scrapedEvent, error) {
	timeUnixNano, err := strconv.Atoi(event.TimeUnixNano)
	if err != nil {
		return nil, fmt.Errorf("provided event time (%s) is not a valid integer: %w", event.TimeUnixNano, err)
	}

	triggerTime := time.Unix(0, int64(timeUnixNano))
	var vulnerabilityExternalID, callableFastenID, mitigationStrategy, severity string

	for _, attribute := range event.Attributes {
		switch attribute.Key {
		case vulnerabilityExternalIdEventAttributeName:
			if attribute.Value.StringValue == nil {
				return nil, fmt.Errorf("error when extracting vulnerability external ID: %w", ErrMissingAttributeValue)
			}
			vulnerabilityExternalID = *attribute.Value.StringValue
		case callableFastenIdEventAttributeName:
			if attribute.Value.StringValue == nil {
				return nil, fmt.Errorf("error when extracting callable FASTEN ID: %w", ErrMissingAttributeValue)
			}
			callableFastenID = *attribute.Value.StringValue
		case mitigationStrategyEventAttributeName:
			if attribute.Value.StringValue == nil {
				return nil, fmt.Errorf("error when extracting mitigation strategy: %w", ErrMissingAttributeValue)
			}
			mitigationStrategy = *attribute.Value.StringValue
		case severityEventAttributeName:
			if attribute.Value.StringValue == nil {
				return nil, fmt.Errorf("error when extracting severity: %w", ErrMissingAttributeValue)
			}
			severity = *attribute.Value.StringValue
		}
	}

	if vulnerabilityExternalID == "" {
		return nil, fmt.Errorf("vulnerability external ID could not be extracted: %w", ErrIncompleteEvent)
	}
	if callableFastenID == "" {
		return nil, fmt.Errorf("callable FASTEN ID could not be extracted: %w", ErrIncompleteEvent)
	}
	if mitigationStrategy == "" {
		return nil, fmt.Errorf("mitigation strategy could not be extracted: %w", ErrIncompleteEvent)
	}
	if severity == "" {
		return nil, fmt.Errorf("severity could not be extracted: %w", ErrIncompleteEvent)
	}

	return &scrapedEvent{
		VulnerabilityExternalID: vulnerabilityExternalID,
		CallableFastenID:        callableFastenID,
		TriggerTime:             triggerTime,
		MitigationStrategy:      mitigationStrategy,
		Severity:                severity,
	}, nil
}
