package service

import (
	"context"
	"errors"
	"fmt"
	"github.com/sirupsen/logrus"
	"sync"
	"time"
	"vulnerabilitytracer/api/generated/managerapi"
	"vulnerabilitytracer/api/generated/tempoquerierapi"
	"vulnerabilitytracer/pkg/manager/runtime"
	"vulnerabilitytracer/pkg/manager/tempoquerier"
)

var (
	ErrParallelProcessingErrors = errors.New("incomplete results from parallel processing")
)

func GetDashboardVulnerabilities(ctx context.Context, runtimeCtx runtime.Context, from time.Time, to time.Time) ([]managerapi.Vulnerability, error) {
	// Get all relevant services
	services, err := runtimeCtx.DBQueries.GetLatestRegisteredServices(ctx)
	if err != nil {
		return nil, fmt.Errorf("error when fetching services from database: %w", err)
	}

	serviceNames := make([]string, len(services))
	for i, service := range services {
		serviceNames[i] = service.Name
	}

	// Search Tempo for traces of all the services
	serviceTraceIDs, err := searchTempoTraces(ctx, runtimeCtx, serviceNames, from, to)

	// Query each trace
	_, err = queryTempoTraces(ctx, runtimeCtx, serviceTraceIDs, from, to)

	// TODO: Aggregate data (extract vulnerability events, potentially mapping them to services)

	return nil, nil
}

// searchTempoTraces returns a map of service name to trace IDs that match the services and time range
func searchTempoTraces(ctx context.Context, runtimeCtx runtime.Context,
	serviceNames []string, from time.Time, to time.Time,
) (map[string][]string, error) {
	type serviceTraces struct {
		serviceName string
		traces      []tempoquerierapi.TraceSearchResult
	}

	waitGroup := new(sync.WaitGroup)
	succChan := make(chan serviceTraces)
	errChan := make(chan error)

	for _, serviceName := range serviceNames {
		waitGroup.Add(1)

		serviceName := serviceName
		go func() {
			defer waitGroup.Done()

			result, err := tempoquerier.TraceSearch(ctx, runtimeCtx.TempoQuerierClient, serviceName, from, to)
			if err != nil {
				errChan <- err
			} else {
				succChan <- serviceTraces{
					serviceName: serviceName,
					traces:      result,
				}
			}
		}()
	}

	go func() {
		waitGroup.Wait()
		close(succChan)
		close(errChan)
	}()

	serviceTraceIDs := make(map[string][]string)
	traceCount := 0
	errorCount := 0

L:
	for {
		select {
		case result, ok := <-succChan:
			if !ok {
				break L
			}
			serviceTraceIDs[result.serviceName] = make([]string, 0)
			for _, trace := range result.traces {
				serviceTraceIDs[result.serviceName] = append(serviceTraceIDs[result.serviceName], *trace.TraceID)
				traceCount++
			}
		case err, ok := <-errChan:
			if !ok {
				break L
			}
			logrus.WithError(err).Error("failed to search for service traces")
			errorCount++
		}
	}

	logrus.
		WithField("serviceCount", len(serviceNames)).
		WithField("traceCount", traceCount).
		WithField("errorCount", errorCount).
		Info("finished searching for Tempo traces")

	if errorCount > 0 {
		return nil, ErrParallelProcessingErrors
	}

	return serviceTraceIDs, nil
}

// queryTempoTraces returns a map of service name to traces that match the services and time range
func queryTempoTraces(ctx context.Context, runtimeCtx runtime.Context,
	serviceNames map[string][]string, from time.Time, to time.Time,
) (map[string][]tempoquerierapi.TraceQueryResponsePayload, error) {
	type serviceTrace struct {
		serviceName string
		trace       tempoquerierapi.TraceQueryResponsePayload
	}

	waitGroup := new(sync.WaitGroup)
	succChan := make(chan serviceTrace)
	errChan := make(chan error)

	for serviceName, traceIDs := range serviceNames {
		serviceName := serviceName

		for _, traceID := range traceIDs {
			traceID := traceID

			waitGroup.Add(1)

			go func() {
				defer waitGroup.Done()

				result, err := tempoquerier.TraceQuery(ctx, runtimeCtx.TempoQuerierClient, traceID, from, to)
				if err != nil {
					errChan <- err
				} else {
					succChan <- serviceTrace{
						serviceName: serviceName,
						trace:       result,
					}
				}
			}()
		}
	}

	go func() {
		waitGroup.Wait()
		close(succChan)
		close(errChan)
	}()

	serviceTracesMap := make(map[string][]tempoquerierapi.TraceQueryResponsePayload)
	traceCount := 0
	errorCount := 0

L:
	for {
		select {
		case result, ok := <-succChan:
			if !ok {
				break L
			}
			serviceTracesMap[result.serviceName] = append(serviceTracesMap[result.serviceName], result.trace)
			traceCount++
		case err, ok := <-errChan:
			if !ok {
				break L
			}
			logrus.WithError(err).Error("failed to search for service traces")
			errorCount++
		}
	}

	logrus.
		WithField("serviceCount", len(serviceNames)).
		WithField("traceCount", traceCount).
		WithField("errorCount", errorCount).
		Info("finished querying for Tempo traces")

	if errorCount > 0 {
		return nil, ErrParallelProcessingErrors
	}

	return serviceTracesMap, nil
}
