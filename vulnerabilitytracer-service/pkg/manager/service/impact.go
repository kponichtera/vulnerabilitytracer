package service

import (
	"context"
	"fmt"
	"github.com/jackc/pgx/v5/pgtype"
	"strconv"
	"time"
	"vulnerabilitytracer/api/generated/managerapi"
	"vulnerabilitytracer/db/generated/queries"
	"vulnerabilitytracer/pkg/manager/runtime"
)

type ImpactGraph struct {
	Nodes []managerapi.ImpactGraphNode
	Edges []managerapi.ImpactGraphEdge
}

func GetImpactGraph(ctx context.Context, runtimeCtx runtime.Context,
	vulnerabilityExternalID string, from time.Time, to time.Time, edgeMetric managerapi.ImpactGraphEdgeMetric,
) (*ImpactGraph, error) {
	nodes, err := runtimeCtx.DBQueries.GetImpactGraphNodes(ctx, queries.GetImpactGraphNodesParams{
		VulnerabilityExternalID: vulnerabilityExternalID,
		FromTime: pgtype.Timestamptz{
			Time:  from,
			Valid: true,
		},
		ToTime: pgtype.Timestamptz{
			Time:  to,
			Valid: true,
		},
	})
	if err != nil {
		return nil, fmt.Errorf("error when querying for impact graph nodes: %w", err)
	}

	edges, err := runtimeCtx.DBQueries.GetImpactGraphEdges(ctx, queries.GetImpactGraphEdgesParams{
		VulnerabilityExternalID: vulnerabilityExternalID,
		FromTime: pgtype.Timestamptz{
			Time:  from,
			Valid: true,
		},
		ToTime: pgtype.Timestamptz{
			Time:  to,
			Valid: true,
		},
	})
	if err != nil {
		return nil, fmt.Errorf("error when querying for impact graph nodes: %w", err)
	}

	impactGraph := buildImpactGraph(nodes, edges, edgeMetric)

	return &impactGraph, nil
}

type nodeID struct {
	traceID int64
	spanID  string
}

type servicePair struct {
	sourceServiceName string
	targetServiceName string
}

type impactGraphEdge struct {
	vulnerableTriggers    int
	nonvulnerableTriggers int
}

func buildImpactGraph(nodes []queries.GetImpactGraphNodesRow, edges []queries.GetImpactGraphEdgesRow,
	metric managerapi.ImpactGraphEdgeMetric,
) ImpactGraph {
	// Map node IDs to service names
	idServiceNameMap := make(map[nodeID]string)

	// Map service names to amount of vulnerability triggers
	serviceNameVulnerabilityTriggers := make(map[string]int64)

	for _, node := range nodes {
		idServiceNameMap[nodeID{traceID: node.TraceID, spanID: node.SpanID}] = node.ServiceName
		serviceNameVulnerabilityTriggers[node.ServiceName] += node.VulnerabilityTriggerCount
	}

	// Map service source and target pairs to the list of edges that trigger and not trigger vulnerabilities
	servicePairEdges := make(map[servicePair]impactGraphEdge)

	for _, edge := range edges {
		sourceServiceName := idServiceNameMap[nodeID{traceID: edge.SourceTraceID, spanID: edge.SourceSpanID}]
		targetServiceName := idServiceNameMap[nodeID{traceID: edge.TargetTraceID, spanID: edge.TargetSpanID}]

		edgePair := servicePair{sourceServiceName: sourceServiceName, targetServiceName: targetServiceName}

		graphEdge := servicePairEdges[edgePair]

		if *edge.LeadsToVulnerability {
			graphEdge.vulnerableTriggers++
		} else {
			graphEdge.nonvulnerableTriggers++
		}

		servicePairEdges[edgePair] = graphEdge
	}

	// Collect nodes
	serviceNameNodeIDMap := make(map[string]int)
	nextID := 0

	impactGraphNodes := make([]managerapi.ImpactGraphNode, 0)

	for serviceName, triggerCount := range serviceNameVulnerabilityTriggers {
		serviceNameNodeIDMap[serviceName] = nextID
		impactGraphNodes = append(impactGraphNodes, managerapi.ImpactGraphNode{
			Id:                        nextID,
			ServiceName:               serviceName,
			VulnerabilityTriggerCount: int(triggerCount),
		})
		nextID++
	}

	// Collect edges
	impactGraphEdges := make([]managerapi.ImpactGraphEdge, 0)
	totalEdges := len(edges)

	for edgePair, edge := range servicePairEdges {
		sourceNodeID := serviceNameNodeIDMap[edgePair.sourceServiceName]
		targetNodeID := serviceNameNodeIDMap[edgePair.targetServiceName]

		var label string

		switch metric {
		case managerapi.EDGECOUNT:
			label = strconv.Itoa(edge.vulnerableTriggers) + " / " + strconv.Itoa(edge.vulnerableTriggers+edge.nonvulnerableTriggers)
		case managerapi.EDGEPERCENTAGE:
			percentage := strconv.FormatFloat(float64(edge.vulnerableTriggers)/float64(edge.vulnerableTriggers+edge.nonvulnerableTriggers)*100, 'g', 4, 64)
			label = percentage + " %"
		case managerapi.TOTALPERCENTAGE:
			percentage := strconv.FormatFloat(float64(edge.vulnerableTriggers)/float64(totalEdges)*100, 'g', 4, 64)
			label = percentage + " %"
		}

		impactGraphEdges = append(impactGraphEdges, managerapi.ImpactGraphEdge{
			Label:                  label,
			SourceNodeId:           sourceNodeID,
			TargetNodeId:           targetNodeID,
			VulnerableCallCount:    edge.vulnerableTriggers,
			NonvulnerableCallCount: edge.nonvulnerableTriggers,
		})
	}

	return ImpactGraph{
		Nodes: impactGraphNodes,
		Edges: impactGraphEdges,
	}
}
