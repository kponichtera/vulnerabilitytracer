package eventscraper

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"syscall"
	"time"

	"vulnerabilitytracer/pkg/eventscraper/runtime"

	"github.com/go-co-op/gocron"
	"github.com/sirupsen/logrus"
)

const (
	jobTimeout         = 30 * time.Second
	jobIntervalSeconds = 1
)

type Context struct {
	runtime.Context
	TraceBatchSize uint
	TraceMaxAge    time.Duration
}

func Run(config Config) error {
	runtimeCtx, err := runtime.Build(config.Tempo, config.Database)
	if err != nil {
		return fmt.Errorf("error when building runtime context: %w", err)
	}

	defer runtimeCtx.Close()

	eventScraperCtx := &Context{
		Context:        *runtimeCtx,
		TraceBatchSize: config.TraceBatchSize,
		TraceMaxAge:    config.TraceMaxAge,
	}

	scheduler := gocron.NewScheduler(time.UTC).
		SingletonMode().
		Every(jobIntervalSeconds).Seconds()

	_, err = scheduler.DoWithJobDetails(scraperJobFunc, eventScraperCtx)
	if err != nil {
		return fmt.Errorf("error when scheduling job: %w", err)
	}

	go func() {
		// Shutdown procedure
		shutdown := make(chan os.Signal, 1)
		signal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM)

		received := <-shutdown
		logrus.Infof("%s signal received, shutting down", received.String())
		scheduler.Stop()
	}()

	scheduler.StartBlocking()
	logrus.Info("scheduler shutdown complete")

	return nil
}

func scraperJobFunc(runtimeCtx *Context, job gocron.Job) {
	ctx, cancel := context.WithTimeout(job.Context(), jobTimeout)
	defer cancel()

	err := scrape(ctx, runtimeCtx)
	if err != nil {
		logrus.WithError(err).Error("error when scraping events")
	}
}
