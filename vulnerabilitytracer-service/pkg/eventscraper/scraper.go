package eventscraper

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"time"

	"vulnerabilitytracer/pkg/utils"

	"vulnerabilitytracer/pkg/mitigationstrategies"
	"vulnerabilitytracer/pkg/vulnerabilities"

	"github.com/jackc/pgx/v5"

	"vulnerabilitytracer/api/generated/tempoquerierapi"
	"vulnerabilitytracer/db/generated/queries"
	"vulnerabilitytracer/pkg/tempo"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/sirupsen/logrus"
)

var (
	ErrMissingAttributeValue = errors.New("attribute value is missing")
	ErrIncompleteEvent       = errors.New("event attributes are incomplete, maybe agent is not up to date")
)

func scrape(ctx context.Context, runtimeCtx *Context) error {
	// Determine the oldest time, for which the traces are meant to be collected
	fromTime := time.Now().Add(-runtimeCtx.TraceMaxAge)

	logrus.Info("running scraper")

	// Get traces to scrape
	tracesToScrape, err := getTracesToScrape(ctx, runtimeCtx, fromTime)
	if err != nil {
		return fmt.Errorf("error when getting traces to scrape: %w", err)
	}

	if len(tracesToScrape) == 0 {
		logrus.
			WithField("from", fromTime).
			Info("no traces to scrape")

		return nil
	}

	logrus.Debugf("fetched %d traces from database", len(tracesToScrape))

	// Query Tempo for traces
	tempoTraces := queryTempoTraces(ctx, runtimeCtx, tracesToScrape)
	tempoTraceIDs := utils.GetMapKeys(tempoTraces)

	logrus.Debugf("fetched %d traces from Tempo", len(tempoTraces))

	// Start transaction to persist events and mark traces as scraped in one go
	tx, err := runtimeCtx.DBPool.BeginTx(ctx, pgx.TxOptions{
		IsoLevel: pgx.ReadUncommitted,
	})
	if err != nil {
		return fmt.Errorf("error when starting transaction: %w", err)
	}
	defer tx.Commit(ctx)

	// Extract events, persist them and mark the traces as scraped
	err = extractAndPersistEvents(ctx, runtimeCtx, tx, tempoTraces)
	if err != nil {
		tx.Rollback(ctx)
		return fmt.Errorf("error when extracting and persisting events: %w", err)
	}

	// Mark traces as scraped
	err = markTracesAsScraped(ctx, runtimeCtx, tx, tempoTraceIDs)
	if err != nil {
		tx.Rollback(ctx)
		return fmt.Errorf("error when marking traces as scraped: %w", err)
	}

	logrus.
		WithField("traceCount", len(tempoTraceIDs)).
		Info("marked traces as scraped")

	// Count remaining traces
	unscrapedTraceCount, err := runtimeCtx.DBQueries.CountUnscrapedTraces(ctx, pgtype.Timestamptz{
		Time:  fromTime,
		Valid: true,
	})
	if err != nil {
		tx.Rollback(ctx)
		return fmt.Errorf("error when counting unscraped traces: %w", err)
	}

	logrus.
		WithField("scrapedTraceCount", len(tempoTraceIDs)).
		WithField("remainingTraceCount", unscrapedTraceCount).
		Info("scraper run finished")

	return nil
}

type traceToScrape struct {
	ID      int64
	TempoID string
	Time    time.Time
}

func getTracesToScrape(ctx context.Context, runtimeCtx *Context,
	from time.Time,
) ([]traceToScrape, error) {
	result, err := runtimeCtx.DBQueries.GetTracesToScrape(ctx, queries.GetTracesToScrapeParams{
		Fromtime: pgtype.Timestamptz{
			Time:  from,
			Valid: true,
		},
		BatchSize: int32(runtimeCtx.TraceBatchSize),
	})
	if err != nil {
		return nil, fmt.Errorf("error when querying database for traces to scrape: %w", err)
	}

	tracesToScrape := make([]traceToScrape, len(result))
	for i, trace := range result {
		tracesToScrape[i] = traceToScrape{
			ID:      trace.ID,
			TempoID: trace.TempoID,
			Time:    trace.Time.Time,
		}
	}

	return tracesToScrape, nil
}

func queryTempoTraces(ctx context.Context, runtimeCtx *Context,
	tracesToScrape []traceToScrape,
) map[int64]tempoquerierapi.TraceQueryResponsePayload {
	traces := make(map[int64]tempoquerierapi.TraceQueryResponsePayload)
	traceCount := 0
	errorCount := 0

	for _, trace := range tracesToScrape {
		fromTime := trace.Time.Add(-1 * time.Minute)
		toTime := trace.Time.Add(1 * time.Minute)

		result, err := tempo.TraceQuery(ctx, runtimeCtx.TempoQuerierClient, trace.TempoID, fromTime, toTime)
		if err != nil {
			logrus.WithError(err).Error("failed to search for service traces")
			errorCount++
		} else {
			traces[trace.ID] = result
			traceCount++
		}
	}

	logrus.
		WithField("traceCount", traceCount).
		WithField("errorCount", errorCount).
		Info("finished querying for Tempo traces")

	return traces
}

const vulnerabilityTriggeredEventName = "vulnerability-triggered"

type scrapedEvent struct {
	VulnerabilityExternalID string
	CallableFastenID        string
	TriggerTime             time.Time
	MitigationStrategy      queries.ServiceMitigationStrategyType
	Severity                queries.VulnerabilitiesSeverity
}

func markTracesAsScraped(ctx context.Context, runtimeCtx *Context, tx pgx.Tx,
	traceIDs []int64,
) error {
	err := runtimeCtx.DBQueries.WithTx(tx).SetTracesAsScraped(ctx, traceIDs)
	if err != nil {
		return fmt.Errorf("error when marking traces as scraped: %w", err)
	}
	return nil
}

func extractAndPersistEvents(ctx context.Context, runtimeCtx *Context, tx pgx.Tx,
	traces map[int64]tempoquerierapi.TraceQueryResponsePayload,
) error {
	scrapedTraceCount := 0
	scrapeErrorCount := 0
	persistedEventCount := 0

	// Extract and persist events
	for traceId, trace := range traces {
		events, err := extractEvents(trace)
		if err != nil {
			scrapeErrorCount++
			logrus.
				WithError(err).
				WithField("traceID", traceId).
				Warn("trace events could not be processed, trace will be skipped")

			continue
		}

		scrapedTraceCount++

		if len(events) == 0 {
			logrus.
				WithField("traceID", traceId).
				Debug("trace has no events")
		} else {
			for _, event := range events {
				err := runtimeCtx.DBQueries.WithTx(tx).InsertEvent(ctx, queries.InsertEventParams{
					TraceID:                 traceId,
					CallableFastenID:        event.CallableFastenID,
					VulnerabilityExternalID: event.VulnerabilityExternalID,
					MitigationStrategy:      event.MitigationStrategy,
					Severity:                event.Severity,
					Time: pgtype.Timestamptz{
						Time:  event.TriggerTime,
						Valid: true,
					},
				})
				if err != nil {
					return fmt.Errorf("error when persisting event for trace %d: %w", traceId, err)
				}

				logrus.
					WithField("traceID", traceId).
					Debug("trace event persisted in the database")
				persistedEventCount++
			}

			logrus.
				WithField("traceID", traceId).
				WithField("eventCount", len(events)).
				Debug("scraped events from a trace")
		}
	}

	logrus.
		WithField("scrapedTraceCount", scrapedTraceCount).
		WithField("scrapeErrorCount", scrapeErrorCount).
		WithField("persistedEventCount", persistedEventCount).
		Info("finished persisting events")

	return nil
}

func extractEvents(trace tempoquerierapi.TraceQueryResponsePayload) ([]scrapedEvent, error) {
	events := make([]scrapedEvent, 0)

	for _, batch := range trace.Batches {
		for _, scopeSpan := range batch.ScopeSpans {
			for _, span := range scopeSpan.Spans {
				if span.Events == nil || len(*span.Events) == 0 {
					// No events in the span, continue to the next one
					continue
				}
				for _, event := range *span.Events {
					if event.Name != vulnerabilityTriggeredEventName {
						// Not a vulnerability trigger event, continue to the next one
						continue
					}

					extractedEvent, err := extractEvent(event)
					if err != nil {
						return nil, fmt.Errorf("error when extracting event: %w", err)
					}
					events = append(events, *extractedEvent)
				}
			}
		}
	}
	return events, nil
}

const (
	vulnerabilityExternalIdEventAttributeName = "externalId"
	callableFastenIdEventAttributeName        = "fastenId"
	mitigationStrategyEventAttributeName      = "mitigationStrategy"
	severityEventAttributeName                = "severity"
)

func extractEvent(event tempoquerierapi.SpanEvent) (*scrapedEvent, error) {
	timeUnixNano, err := strconv.Atoi(event.TimeUnixNano)
	if err != nil {
		return nil, fmt.Errorf("provided event time (%s) is not a valid integer: %w", event.TimeUnixNano, err)
	}

	triggerTime := time.Unix(0, int64(timeUnixNano))
	var vulnerabilityExternalID, callableFastenID, mitigationStrategy, severity string

	for _, attribute := range event.Attributes {
		switch attribute.Key {
		case vulnerabilityExternalIdEventAttributeName:
			if attribute.Value.StringValue == nil {
				return nil, fmt.Errorf("error when extracting vulnerability external ID: %w", ErrMissingAttributeValue)
			}
			vulnerabilityExternalID = *attribute.Value.StringValue
		case callableFastenIdEventAttributeName:
			if attribute.Value.StringValue == nil {
				return nil, fmt.Errorf("error when extracting callable FASTEN ID: %w", ErrMissingAttributeValue)
			}
			callableFastenID = *attribute.Value.StringValue
		case mitigationStrategyEventAttributeName:
			if attribute.Value.StringValue == nil {
				return nil, fmt.Errorf("error when extracting mitigation strategy: %w", ErrMissingAttributeValue)
			}
			mitigationStrategy = *attribute.Value.StringValue
		case severityEventAttributeName:
			if attribute.Value.StringValue == nil {
				return nil, fmt.Errorf("error when extracting severity: %w", ErrMissingAttributeValue)
			}
			severity = *attribute.Value.StringValue
		}
	}

	if vulnerabilityExternalID == "" {
		return nil, fmt.Errorf("vulnerability external ID could not be extracted: %w", ErrIncompleteEvent)
	}
	if callableFastenID == "" {
		return nil, fmt.Errorf("callable FASTEN ID could not be extracted: %w", ErrIncompleteEvent)
	}
	if mitigationStrategy == "" {
		return nil, fmt.Errorf("mitigation strategy could not be extracted: %w", ErrIncompleteEvent)
	}
	if severity == "" {
		return nil, fmt.Errorf("severity could not be extracted: %w", ErrIncompleteEvent)
	}

	return &scrapedEvent{
		VulnerabilityExternalID: vulnerabilityExternalID,
		CallableFastenID:        callableFastenID,
		TriggerTime:             triggerTime,
		MitigationStrategy:      mitigationstrategies.ConvertStringToDatabaseEnum(&mitigationStrategy),
		Severity:                vulnerabilities.ConvertStringToDatabaseEnum(severity),
	}, nil
}
