package eventscraper

import (
	"context"
	"fmt"
	"sync"
	"time"

	"vulnerabilitytracer/api/generated/tempoquerierapi"
	"vulnerabilitytracer/db/generated/queries"
	"vulnerabilitytracer/pkg/tempo"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/sirupsen/logrus"
)

func scrape(ctx context.Context, runtimeCtx *Context) error {
	// Determine the oldest time, for which the traces are meant to be collected
	fromTime := time.Now().Add(-runtimeCtx.TraceMaxAge)

	logrus.
		WithField("from", fromTime).
		Info("running scraper")

	// Get traces to scrape
	tracesToScrape, err := getTracesToScrape(ctx, runtimeCtx, fromTime)
	if err != nil {
		return fmt.Errorf("error when getting traces to scrape: %w", err)
	}

	logrus.Debugf("fetched %d traces from database", len(tracesToScrape))

	// Query Tempo for traces
	_, err = queryTempoTraces(ctx, runtimeCtx, tracesToScrape)

	logrus.Debugf("fetched %d traces from Tempo", len(tracesToScrape))

	return nil
}

type traceToScrape struct {
	ID      int64
	TempoID string
	Time    time.Time
}

func getTracesToScrape(ctx context.Context, runtimeCtx *Context,
	from time.Time,
) ([]traceToScrape, error) {
	result, err := runtimeCtx.DBQueries.GetTracesToScrape(ctx, queries.GetTracesToScrapeParams{
		Fromtime: pgtype.Timestamptz{
			Time:  from,
			Valid: true,
		},
		BatchSize: int32(runtimeCtx.TraceBatchSize),
	})
	if err != nil {
		return nil, fmt.Errorf("error when querying database for traces to scrape: %w", err)
	}

	tracesToScrape := make([]traceToScrape, len(result))
	for i, trace := range result {
		tracesToScrape[i] = traceToScrape{
			ID:      trace.ID,
			TempoID: trace.TempoID,
			Time:    trace.Time.Time,
		}
	}

	return tracesToScrape, nil
}

func queryTempoTraces(ctx context.Context, runtimeCtx *Context,
	tracesToScrape []traceToScrape,
) ([]tempoquerierapi.TraceQueryResponsePayload, error) {
	waitGroup := new(sync.WaitGroup)
	succChan := make(chan tempoquerierapi.TraceQueryResponsePayload)
	errChan := make(chan error)

	for _, trace := range tracesToScrape {
		fromTime := trace.Time.Add(-1 * time.Minute)
		toTime := trace.Time.Add(1 * time.Minute)
		trace := trace

		waitGroup.Add(1)

		go func() {
			defer waitGroup.Done()

			result, err := tempo.TraceQuery(ctx, runtimeCtx.TempoQuerierClient, trace.TempoID, fromTime, toTime)
			if err != nil {
				errChan <- err
			} else {
				succChan <- result
			}
		}()
	}

	go func() {
		waitGroup.Wait()
		close(succChan)
		close(errChan)
	}()

	traces := make([]tempoquerierapi.TraceQueryResponsePayload, 0)
	traceCount := 0
	errorCount := 0

L:
	for {
		select {
		case result, ok := <-succChan:
			if !ok {
				break L
			}
			traces = append(traces, result)
			traceCount++
		case err, ok := <-errChan:
			if !ok {
				break L
			}
			logrus.WithError(err).Error("failed to search for service traces")
			errorCount++
		}
	}

	logrus.
		WithField("traceCount", traceCount).
		WithField("errorCount", errorCount).
		Info("finished querying for Tempo traces")

	if errorCount > 0 {
		return nil, fmt.Errorf("failed to query for %d traces", errorCount)
	}

	return traces, nil
}
