package serviceobserver

import (
	"context"
	"fmt"
	"time"

	"vulnerabilitytracer/pkg/tracescraper/servicescraper"

	mapset "github.com/deckarep/golang-set/v2"
	"github.com/go-co-op/gocron"
	"github.com/sirupsen/logrus"
)

const (
	serviceScraperJobIntervalSeconds = 10
	serviceScraperJobTimeout         = 30 * time.Second
)

func reconcile(ctx context.Context, runtimeCtx *Context) error {
	logrus.
		WithField("observedServices", len(runtimeCtx.ObservedServices)).
		Info("reconciliation loop starting")

	// Get current services from the database
	services, err := runtimeCtx.DBQueries.GetServicesForObserving(ctx)
	if err != nil {
		return fmt.Errorf("error when fetching services from database: %w", err)
	}

	serviceNames := make([]string, len(services))
	for i, service := range services {
		serviceNames[i] = service.Name
	}

	// Stop observing old services
	stopObserving(runtimeCtx, serviceNames)

	// Start observing new services
	err = startObserving(runtimeCtx, serviceNames)
	if err != nil {
		return fmt.Errorf("error when starting to observe services: %w", err)
	}

	logrus.
		WithField("observedServices", len(runtimeCtx.ObservedServices)).
		Info("reconciliation loop complete")

	return nil
}

func stopObserving(runtimeCtx *Context, serviceNames []string) {
	serviceNamesToStop := make(map[string]*gocron.Scheduler)
	for serviceName, scheduler := range runtimeCtx.ObservedServices {
		serviceNamesToStop[serviceName] = scheduler
	}

	// Remove services that we want to keep observing
	for _, serviceToKeep := range serviceNames {
		delete(serviceNamesToStop, serviceToKeep)
	}

	// Stop the observing schedulers of the services
	for serviceName, scheduler := range serviceNamesToStop {
		logrus.
			WithField("serviceName", serviceName).
			Info("stopping service scraper")

		scheduler.Stop()
		delete(runtimeCtx.ObservedServices, serviceName)
	}
}

func startObserving(runtimeCtx *Context, serviceNames []string) error {
	newServiceNamesToObserve := mapset.NewSet[string](serviceNames...)

	// Remove the services that we are already observing
	for serviceName := range runtimeCtx.ObservedServices {
		newServiceNamesToObserve.Remove(serviceName)
	}

	// Observe new services
	for newServiceName := range newServiceNamesToObserve.Iter() {
		serviceScraperCtx := &servicescraper.Context{
			Context:        runtimeCtx.Context,
			ServiceName:    newServiceName,
			ScrapeDelay:    runtimeCtx.ScrapeDelay,
			ScrapeInterval: runtimeCtx.ScrapeInterval,
		}

		scheduler := gocron.NewScheduler(time.UTC).
			SingletonMode().
			Every(serviceScraperJobIntervalSeconds).Seconds()

		_, err := scheduler.DoWithJobDetails(scraperJobFunc, serviceScraperCtx)
		if err != nil {
			return fmt.Errorf("error when scheduling scraper job: %w", err)
		}

		runtimeCtx.ObservedServices[newServiceName] = scheduler

		logrus.
			WithField("serviceName", newServiceName).
			Info("starting service scraper")

		scheduler.StartAsync()
	}

	return nil
}

func scraperJobFunc(runtimeCtx *servicescraper.Context, job gocron.Job) {
	ctx, cancel := context.WithTimeout(job.Context(), serviceScraperJobTimeout)
	defer cancel()

	err := servicescraper.Scrape(ctx, runtimeCtx)
	if err != nil {
		logrus.WithError(err).Error("error when scraping service")
	}
}
