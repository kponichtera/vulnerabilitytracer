package tracegraph

import (
	"errors"
	"fmt"

	"github.com/dominikbraun/graph"
)

var (
	ErrGraphNotRooted         = errors.New("graph is not rooted")
	ErrRootedGraphWithoutRoot = errors.New("could not find a root node in the graph")
)

func FindRoot[K comparable, T any](graph graph.Graph[K, T]) (*K, error) {
	if !graph.Traits().IsRooted {
		return nil, ErrGraphNotRooted
	}

	predecessorMap, err := graph.PredecessorMap()
	if err != nil {
		return nil, fmt.Errorf("failed to get predecessor map: %w", err)
	}

	var root *K

	for nodeID, predecessors := range predecessorMap {
		if len(predecessors) == 0 {
			root = &nodeID

			break
		}
	}

	if root == nil {
		return nil, ErrRootedGraphWithoutRoot
	}

	return root, nil
}

func Equal(graph1 Graph, graph2 Graph) (bool, error) {
	// Graphs are equal if they have the same vertices, edges and events

	map1, err := graph1.AdjacencyMap()
	if err != nil {
		return false, fmt.Errorf("failed to get adjacency map for the first graph: %w", err)
	}

	map2, err := graph2.AdjacencyMap()
	if err != nil {
		return false, fmt.Errorf("failed to get adjacency map for the second graph: %w", err)
	}

	for vertex1ID, edges1 := range map1 {
		edges2, ok := map2[vertex1ID]
		if !ok {
			// Second graph does not have the same vertex
			return false, nil
		}

		if len(edges1) != len(edges2) {
			// Vertex in the second graph has different amount of edges
			return false, nil
		}

		for successorVertexID1 := range edges1 {
			_, ok := edges2[successorVertexID1]
			if !ok {
				// Outgoing edges in the second graph are different
				return false, nil
			}
		}

		vertex1, _ := graph1.Vertex(vertex1ID)
		vertex2, _ := graph2.Vertex(vertex1ID)

		if !checkEventListEqual(vertex1.Events, vertex2.Events) {
			// Vertex in the second graph has different events
			return false, nil
		}

	}

	return true, nil
}

func checkEventListEqual(slice1, slice2 []Event) bool {
	if len(slice1) != len(slice2) {
		return false
	}

	elementCount := make(map[Event]int)

	for _, elem := range slice1 {
		elementCount[elem]++
	}

	for _, elem := range slice2 {
		if elementCount[elem] == 0 {
			return false // Found more of `elem` in slice2 than in slice1
		}
		elementCount[elem]--
	}

	for _, count := range elementCount {
		if count != 0 {
			return false // Some elements were not matched
		}
	}

	return true
}

func ReplaceVertex(graph Graph, vertexID NodeID, newVertex Node) error {
	successorMap, err := graph.AdjacencyMap()
	predecessorMap, err := graph.PredecessorMap()

	// Handle incoming edges of the replaced node
	incomingEdges := predecessorMap[vertexID]
	for predecessorID := range incomingEdges {
		// Disconnect the incoming edges of the replaced node
		err = graph.RemoveEdge(predecessorID, vertexID)
		if err != nil {
			return fmt.Errorf("failed to disconnect the outgoing edge of the replaced node: %w", err)
		}
	}

	// Handle outgoing edges of the reduced node
	outgoingEdges := successorMap[vertexID]
	for successorID := range outgoingEdges {
		// Disconnect the outgoing edges of the reduced node
		err = graph.RemoveEdge(vertexID, successorID)
		if err != nil {
			return fmt.Errorf("failed to disconnect the outgoing edge of the replaced node: %w", err)
		}
	}

	// Remove the old vertex
	err = graph.RemoveVertex(vertexID)
	if err != nil {
		return fmt.Errorf("failed to remove the old node: %w", err)
	}

	// Add the new vertex
	err = graph.AddVertex(newVertex)
	if err != nil {
		return fmt.Errorf("failed to add the new node: %w", err)
	}

	// Connect the incoming edges of the old node to the new one
	for predecessorID := range incomingEdges {
		err = graph.AddEdge(predecessorID, vertexID)
		if err != nil {
			return fmt.Errorf("failed to connect the incoming edge of the replaced node: %w", err)
		}
	}

	// Connect the outgoing edges of the old node to the new one
	for successorID := range outgoingEdges {
		err = graph.AddEdge(vertexID, successorID)
		if err != nil {
			return fmt.Errorf("failed to connect the outgoing edge of the replaced node: %w", err)
		}
	}

	return nil
}
