package tracegraph_test

import (
	"testing"

	"vulnerabilitytracer/pkg/tracegraph"

	"github.com/stretchr/testify/require"
)

func TestMergingNodes(t *testing.T) {
	tests := []struct {
		name         string
		inputGraph   tracegraph.Graph
		reducedGraph tracegraph.Graph
		returnsError bool
	}{
		{
			name:         "reducing straight impact graph works",
			inputGraph:   buildStraightGraph(),
			reducedGraph: buildReducedStraightGraph(),
			returnsError: false,
		},
		{
			name:         "reducing reduced straight impact graph returns the same graph",
			inputGraph:   buildReducedStraightGraph(),
			reducedGraph: buildReducedStraightGraph(),
			returnsError: false,
		},
		{
			name:         "reducing tree impact graph works",
			inputGraph:   buildTreeGraph(),
			reducedGraph: buildReducedTreeGraph(),
			returnsError: false,
		},
		{
			name:         "reducing reduced tree impact returns the same graph",
			inputGraph:   buildReducedTreeGraph(),
			reducedGraph: buildReducedTreeGraph(),
			returnsError: false,
		},
		{
			name:         "reducing non-rooted impact graph works",
			inputGraph:   buildNonRootedGraph(),
			reducedGraph: buildReducedNonRootedGraph(),
			returnsError: false,
		},
		{
			name:         "reducing reduced non-rooted impact graph returns the same graph",
			inputGraph:   buildReducedNonRootedGraph(),
			reducedGraph: buildReducedNonRootedGraph(),
			returnsError: false,
		},
		{
			name:         "reducing impact graph on the junction works",
			inputGraph:   buildJunctionReductionGraph(),
			reducedGraph: buildReducedJunctionReductionGraph(),
			returnsError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// When
			reducedGraph, err := tracegraph.Reduce(tt.inputGraph)

			// Then
			if tt.returnsError {
				require.Error(t, err)
			} else {
				require.NoError(t, err)

				reducedGraphsEqual, err := tracegraph.Equal(reducedGraph, tt.reducedGraph)
				if err != nil {
					require.Failf(t, "error in utility method", "failed to compare reduced graphs: %w", err)
				}

				require.True(t, reducedGraphsEqual)
			}
		})
	}
}

func TestPruningLeaves(t *testing.T) {
	tests := []struct {
		name         string
		inputGraph   tracegraph.Graph
		reducedGraph tracegraph.Graph
		returnsError bool
	}{
		{
			name:         "pruning sibling leaf works",
			inputGraph:   buildSiblingLeafGraph(),
			reducedGraph: buildPrunedSiblingLeafGraph(),
			returnsError: false,
		},
		{
			name:         "pruning sibling leafs of the pruned graph returns the same graph",
			inputGraph:   buildPrunedSiblingLeafGraph(),
			reducedGraph: buildPrunedSiblingLeafGraph(),
			returnsError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// When
			reducedGraph, err := tracegraph.Reduce(tt.inputGraph)

			// Then
			if tt.returnsError {
				require.Error(t, err)
			} else {
				require.NoError(t, err)

				reducedGraphsEqual, err := tracegraph.Equal(reducedGraph, tt.reducedGraph)
				if err != nil {
					require.Failf(t, "error in utility method", "failed to compare reduced graphs: %w", err)
				}

				require.True(t, reducedGraphsEqual)
			}
		})
	}
}

func TestGraphReducing(t *testing.T) {
	tests := []struct {
		name         string
		inputGraph   tracegraph.Graph
		reducedGraph tracegraph.Graph
		returnsError bool
	}{
		{
			name:         "reducing a graph with service chains and sibling leafs works",
			inputGraph:   buildNonMergedGraphWithSiblingLeaf(),
			reducedGraph: buildMergedGraphWithoutSiblingLeaf(),
			returnsError: false,
		},
		{
			name:         "reducing reduced graph without service chains and sibling leafs returns the same graph",
			inputGraph:   buildMergedGraphWithoutSiblingLeaf(),
			reducedGraph: buildMergedGraphWithoutSiblingLeaf(),
			returnsError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// When
			reducedGraph, err := tracegraph.Reduce(tt.inputGraph)

			// Then
			if tt.returnsError {
				require.Error(t, err)
			} else {
				require.NoError(t, err)

				reducedGraphsEqual, err := tracegraph.Equal(reducedGraph, tt.reducedGraph)
				if err != nil {
					require.Failf(t, "error in utility method", "failed to compare reduced graphs: %w", err)
				}

				require.True(t, reducedGraphsEqual)
			}
		})
	}
}

func BenchmarkGraphReducing(b *testing.B) {
	graph := buildNonMergedGraphWithSiblingLeaf()
	for i := 0; i < b.N; i++ {
		_, _ = tracegraph.Reduce(graph)
	}
}

func buildStraightGraph() tracegraph.Graph {
	resultGraph := tracegraph.New()
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "1",
		ServiceName: "service-1",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "2",
		ServiceName: "service-2",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "3",
		ServiceName: "service-2",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "4",
		ServiceName: "service-3",
	})

	_ = resultGraph.AddEdge("1", "2")
	_ = resultGraph.AddEdge("2", "3")
	_ = resultGraph.AddEdge("3", "4")

	return resultGraph
}

func buildReducedStraightGraph() tracegraph.Graph {
	resultGraph := tracegraph.New()
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "1",
		ServiceName: "service-1",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "3",
		ServiceName: "service-2",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "4",
		ServiceName: "service-3",
	})

	_ = resultGraph.AddEdge("1", "3")
	_ = resultGraph.AddEdge("3", "4")

	return resultGraph
}

func buildTreeGraph() tracegraph.Graph {
	resultGraph := tracegraph.New()
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "1",
		ServiceName: "service-1",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "2",
		ServiceName: "service-2",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "3",
		ServiceName: "service-2",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "4",
		ServiceName: "service-3",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "5",
		ServiceName: "service-4",
	})

	_ = resultGraph.AddEdge("1", "2")
	_ = resultGraph.AddEdge("2", "3")
	_ = resultGraph.AddEdge("3", "4")
	_ = resultGraph.AddEdge("3", "5")

	return resultGraph
}

func buildReducedTreeGraph() tracegraph.Graph {
	resultGraph := tracegraph.New()
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "1",
		ServiceName: "service-1",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "3",
		ServiceName: "service-2",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "4",
		ServiceName: "service-3",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "5",
		ServiceName: "service-4",
	})

	_ = resultGraph.AddEdge("1", "3")
	_ = resultGraph.AddEdge("3", "4")
	_ = resultGraph.AddEdge("3", "5")

	return resultGraph
}

func buildNonRootedGraph() tracegraph.Graph {
	resultGraph := tracegraph.New()
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "1",
		ServiceName: "service-1",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "2",
		ServiceName: "service-2",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "3",
		ServiceName: "service-2",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "4",
		ServiceName: "service-3",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "5",
		ServiceName: "service-4",
	})

	_ = resultGraph.AddEdge("1", "2")
	_ = resultGraph.AddEdge("2", "3")
	_ = resultGraph.AddEdge("4", "3")
	_ = resultGraph.AddEdge("5", "3")

	return resultGraph
}

func buildReducedNonRootedGraph() tracegraph.Graph {
	resultGraph := tracegraph.New()
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "1",
		ServiceName: "service-1",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "3",
		ServiceName: "service-2",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "4",
		ServiceName: "service-3",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "5",
		ServiceName: "service-4",
	})

	_ = resultGraph.AddEdge("1", "3")
	_ = resultGraph.AddEdge("4", "3")
	_ = resultGraph.AddEdge("5", "3")

	return resultGraph
}

// buildJunctionReductionGraph generates a graph, which looks like this:
//
// 1 -> 2 -> 3
//
//	|
//	.--> 2
func buildJunctionReductionGraph() tracegraph.Graph {
	resultGraph := tracegraph.New()
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "1",
		ServiceName: "service-1",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "2",
		ServiceName: "service-2",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "3",
		ServiceName: "service-2",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "4",
		ServiceName: "service-3",
	})

	_ = resultGraph.AddEdge("1", "2")
	_ = resultGraph.AddEdge("2", "3")
	_ = resultGraph.AddEdge("2", "4")

	return resultGraph
}

// buildReducedJunctionReductionGraph generates a graph, which looks like this:
//
// 1 -> 2 -> 3
func buildReducedJunctionReductionGraph() tracegraph.Graph {
	resultGraph := tracegraph.New()
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "1",
		ServiceName: "service-1",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "3",
		ServiceName: "service-2",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "4",
		ServiceName: "service-3",
	})

	_ = resultGraph.AddEdge("1", "3")
	_ = resultGraph.AddEdge("3", "4")

	return resultGraph
}

// buildSiblingLeafGraph generates a graph that has a sibling node on the junction,
// simulating addition of a span by a different trace reporter:
// 1 -> 2 -> 3
//
//	|
//	.--> 3 -> 4
func buildSiblingLeafGraph() tracegraph.Graph {
	resultGraph := tracegraph.New()
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "1",
		ServiceName: "service-1",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "2",
		ServiceName: "service-2",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "3",
		ServiceName: "service-3",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "4",
		ServiceName: "service-3",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "5",
		ServiceName: "service-4",
	})

	_ = resultGraph.AddEdge("1", "2")
	_ = resultGraph.AddEdge("2", "3")
	_ = resultGraph.AddEdge("2", "4")
	_ = resultGraph.AddEdge("4", "5")

	return resultGraph
}

// buildSiblingLeafGraph generates a graph that had a sibling node on the junction
// and has been pruned:
// 1 -> 2
//
//	|
//	.--> 3 -> 4
func buildPrunedSiblingLeafGraph() tracegraph.Graph {
	resultGraph := tracegraph.New()
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "1",
		ServiceName: "service-1",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "2",
		ServiceName: "service-2",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "4",
		ServiceName: "service-3",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "5",
		ServiceName: "service-4",
	})

	_ = resultGraph.AddEdge("1", "2")
	_ = resultGraph.AddEdge("2", "4")
	_ = resultGraph.AddEdge("4", "5")

	return resultGraph
}

// buildNonMergedGraphWithSiblingLeaf generates a graph that has a sibling node
// and a duplicate node on the junction:
// 1 -> 2 -> 2
//
//		|
//		.--> 3
//	 |
//	 .--> 3 -> 4
func buildNonMergedGraphWithSiblingLeaf() tracegraph.Graph {
	resultGraph := tracegraph.New()
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "1",
		ServiceName: "service-1",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "2",
		ServiceName: "service-2",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "3",
		ServiceName: "service-2",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "4",
		ServiceName: "service-3",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "5",
		ServiceName: "service-3",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "6",
		ServiceName: "service-4",
	})

	_ = resultGraph.AddEdge("1", "2")
	_ = resultGraph.AddEdge("2", "3")
	_ = resultGraph.AddEdge("2", "4")
	_ = resultGraph.AddEdge("2", "5")
	_ = resultGraph.AddEdge("5", "6")

	return resultGraph
}

// buildNonMergedGraphWithSiblingLeaf generates a graph that has a sibling node
// and a duplicate node on the junction:
// 1 -> 2
//
//	|
//	.--> 3 -> 4
func buildMergedGraphWithoutSiblingLeaf() tracegraph.Graph {
	resultGraph := tracegraph.New()
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "1",
		ServiceName: "service-1",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "3",
		ServiceName: "service-2",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "5",
		ServiceName: "service-3",
	})
	_ = resultGraph.AddVertex(tracegraph.Node{
		ID:          "6",
		ServiceName: "service-4",
	})

	_ = resultGraph.AddEdge("1", "3")
	_ = resultGraph.AddEdge("3", "5")
	_ = resultGraph.AddEdge("5", "6")

	return resultGraph
}
