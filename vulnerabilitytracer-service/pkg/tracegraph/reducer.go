package tracegraph

import (
	"fmt"

	"github.com/dominikbraun/graph"
)

// Reduce performs a reduction of the trace graph by merging the adjacent edges with the same service names
func Reduce(impactGraph Graph) (Graph, error) {
	reducedGraph, err := impactGraph.Clone()
	if err != nil {
		return nil, fmt.Errorf("failed to clone trace graph: %w", err)
	}

	searchRoot, err := FindRoot(reducedGraph)
	if err != nil {
		return nil, fmt.Errorf("failed to find root in trace graph: %w", err)
	}

	for {
		var nodeIDToReduce, successorID NodeID

		predecessorMap, err := reducedGraph.PredecessorMap()
		if err != nil {
			return nil, fmt.Errorf("failed to get predecessor map: %w", err)
		}

		successorMap, err := reducedGraph.AdjacencyMap()
		if err != nil {
			return nil, fmt.Errorf("failed to get successor map: %w", err)
		}

		err = graph.BFS(reducedGraph, *searchRoot, func(nodeID NodeID) bool {
			node, _ := reducedGraph.Vertex(nodeID)
			predecessors := predecessorMap[nodeID]
			for predecessorID := range predecessors {
				// Check if there is any predecessor with the same service name
				predecessorNode, _ := reducedGraph.Vertex(predecessorID)
				if predecessorNode.ServiceName == node.ServiceName {
					successorID = nodeID
					nodeIDToReduce = predecessorID

					return true
				}
			}

			return false
		})
		if err != nil {
			return nil, fmt.Errorf("failed to perform search on the trace graph: %w", err)
		}

		if nodeIDToReduce == "" {
			// No more nodes to reduce
			break
		}

		// Handle incoming edges of the reduced node
		incomingEdges := predecessorMap[nodeIDToReduce]
		for predecessorID := range incomingEdges {
			// Connect incoming edges of reduced node to successor
			err := reducedGraph.AddEdge(predecessorID, successorID)
			if err != nil {
				return nil, fmt.Errorf("failed to connect incoming edge of reduced node to successor: %w", err)
			}

			// Disconnect the incoming edges of the reduced node
			err = reducedGraph.RemoveEdge(predecessorID, nodeIDToReduce)
			if err != nil {
				return nil, fmt.Errorf("failed to disconnect the outgoing edge of the reduced node: %w", err)
			}
		}

		// Handle outgoing edges of the reduced node
		outgoingEdges := successorMap[nodeIDToReduce]
		for reducedSuccessorID := range outgoingEdges {
			// Connect the outgoing edges of the reduced node to its successor
			if reducedSuccessorID != successorID {
				err := reducedGraph.AddEdge(successorID, reducedSuccessorID)
				if err != nil {
					return nil, fmt.Errorf("failed to connect outgoing edge of reduced node to successor: %w", err)
				}
			}

			// Disconnect the outgoing edges of the reduced node
			err = reducedGraph.RemoveEdge(nodeIDToReduce, reducedSuccessorID)
			if err != nil {
				return nil, fmt.Errorf("failed to disconnect the outgoing edge of the reduced node: %w", err)
			}
		}

		// Copy the events from the reduced node to the successor
		reducedNode, _ := reducedGraph.Vertex(nodeIDToReduce)
		successorNode, _ := reducedGraph.Vertex(successorID)
		successorNode.Events = append(successorNode.Events, reducedNode.Events...)

		// Remove the node from the graph
		err = reducedGraph.RemoveVertex(nodeIDToReduce)
		if err != nil {
			return nil, fmt.Errorf("failed to remove node from the trace graph: %w", err)
		}

		// Set the new search root to predecessor
		// searchRoot = &successorID
	}

	return reducedGraph, nil
}
