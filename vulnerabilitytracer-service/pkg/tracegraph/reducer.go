package tracegraph

import (
	"fmt"

	"github.com/dominikbraun/graph"
)

// Reduce performs a reduction of the trace graph by removing unnecessary nodes
func Reduce(impactGraph Graph) (Graph, error) {
	mergedGraph, err := mergeNodes(impactGraph)
	if err != nil {
		return nil, fmt.Errorf("failed to merge nodes of the graph: %w", err)
	}

	prunedGraph, err := pruneLeaves(mergedGraph)
	if err != nil {
		return nil, fmt.Errorf("failed to prune leaves of the graph: %w", err)
	}

	return prunedGraph, nil
}

// mergeNodes performs a reduction of the trace graph by merging the adjacent edges with the same service names
func mergeNodes(impactGraph Graph) (Graph, error) {
	reducedGraph, err := impactGraph.Clone()

	searchRoot, err := FindRoot(reducedGraph)
	if err != nil {
		return nil, fmt.Errorf("failed to find root in trace graph: %w", err)
	}

	for {
		var nodeIDToReduce, successorID NodeID

		predecessorMap, err := reducedGraph.PredecessorMap()
		if err != nil {
			return nil, fmt.Errorf("failed to get predecessor map: %w", err)
		}

		successorMap, err := reducedGraph.AdjacencyMap()
		if err != nil {
			return nil, fmt.Errorf("failed to get successor map: %w", err)
		}

		err = graph.BFS(reducedGraph, *searchRoot, func(nodeID NodeID) bool {
			node, _ := reducedGraph.Vertex(nodeID)
			predecessors := predecessorMap[nodeID]
			for predecessorID := range predecessors {
				// Check if there is any predecessor with the same service name
				predecessorNode, _ := reducedGraph.Vertex(predecessorID)
				if predecessorNode.ServiceName == node.ServiceName {
					successorID = nodeID
					nodeIDToReduce = predecessorID

					return true
				}
			}

			return false
		})
		if err != nil {
			return nil, fmt.Errorf("failed to perform search on the trace graph: %w", err)
		}

		if nodeIDToReduce == "" {
			// No more nodes to reduce
			break
		}

		// Handle incoming edges of the reduced node
		incomingEdges := predecessorMap[nodeIDToReduce]
		for predecessorID := range incomingEdges {
			// Connect incoming edges of reduced node to successor
			err := reducedGraph.AddEdge(predecessorID, successorID)
			if err != nil {
				return nil, fmt.Errorf("failed to connect incoming edge of reduced node to successor: %w", err)
			}

			// Disconnect the incoming edges of the reduced node
			err = reducedGraph.RemoveEdge(predecessorID, nodeIDToReduce)
			if err != nil {
				return nil, fmt.Errorf("failed to disconnect the outgoing edge of the reduced node: %w", err)
			}
		}

		// Handle outgoing edges of the reduced node
		outgoingEdges := successorMap[nodeIDToReduce]
		for reducedSuccessorID := range outgoingEdges {
			// Connect the outgoing edges of the reduced node to its successor
			if reducedSuccessorID != successorID {
				err := reducedGraph.AddEdge(successorID, reducedSuccessorID)
				if err != nil {
					return nil, fmt.Errorf("failed to connect outgoing edge of reduced node to successor: %w", err)
				}
			}

			// Disconnect the outgoing edges of the reduced node
			err = reducedGraph.RemoveEdge(nodeIDToReduce, reducedSuccessorID)
			if err != nil {
				return nil, fmt.Errorf("failed to disconnect the outgoing edge of the reduced node: %w", err)
			}
		}

		// Copy the events from the reduced node to the successor
		reducedNode, _ := reducedGraph.Vertex(nodeIDToReduce)
		successorNode, _ := reducedGraph.Vertex(successorID)
		successorNode.Events = append(successorNode.Events, reducedNode.Events...)

		// Remove the node from the graph
		err = reducedGraph.RemoveVertex(nodeIDToReduce)
		if err != nil {
			return nil, fmt.Errorf("failed to remove node from the trace graph: %w", err)
		}

		// Set the new search root to successor
		// searchRoot = &successorID
	}

	return reducedGraph, nil
}

// pruneLeaves removes sibling leaf nodes from the graph, which are often created when multiple trace reporters,
// like Istio and OpenTelemetry, create spans for the outgoing downstream calls
func pruneLeaves(impactGraph Graph) (Graph, error) {
	prunedGraph, err := impactGraph.Clone()
	if err != nil {
		return nil, fmt.Errorf("failed to clone trace graph: %w", err)
	}

	searchRoot, err := FindRoot(prunedGraph)
	if err != nil {
		return nil, fmt.Errorf("failed to find root in trace graph: %w", err)
	}

	for {
		var predecessorID, nodeIDToPrune NodeID

		successorMap, err := prunedGraph.AdjacencyMap()
		if err != nil {
			return nil, fmt.Errorf("failed to get successor map: %w", err)
		}

		err = graph.BFS(prunedGraph, *searchRoot, func(nodeID NodeID) bool {
			predecessorSuccessors := successorMap[nodeID]

			// Count the successors of the node, by mapping service name to the counter
			successorsCountMap := make(map[string]int)
			successorSuccessorsCountMap := make(map[NodeID]int)
			for successorID := range predecessorSuccessors {
				successorNode, _ := prunedGraph.Vertex(successorID)
				successorsCountMap[successorNode.ServiceName]++
				successorSuccessorsCountMap[successorID] = len(successorMap[successorID])
			}

			for successorID, successorSuccessorsCount := range successorSuccessorsCountMap {
				successorNode, _ := prunedGraph.Vertex(successorID)

				if successorsCountMap[successorNode.ServiceName] > 1 {
					// If the predecessor node has multiple successors with the same service name,
					// check if the currently checked one has no successors. If it doesn't, prune it
					for successorSuccessorsCount == 0 {
						predecessorID = nodeID
						nodeIDToPrune = successorID

						return true
					}
				}
			}

			return false
		})
		if err != nil {
			return nil, fmt.Errorf("failed to perform search on the trace graph: %w", err)
		}

		if nodeIDToPrune == "" {
			// No more nodes to prune
			break
		}

		// Disconnect the node to prune from the predecessor
		err = prunedGraph.RemoveEdge(predecessorID, nodeIDToPrune)
		if err != nil {
			return nil, fmt.Errorf("failed to disconnect the node from its predecessor: %w", err)
		}

		// Remove the node from the graph
		err = prunedGraph.RemoveVertex(nodeIDToPrune)
		if err != nil {
			return nil, fmt.Errorf("failed to remove node from the trace graph: %w", err)
		}

		// Set the new search root to predecessor
		// searchRoot = &predecessorID
	}

	return prunedGraph, nil
}
