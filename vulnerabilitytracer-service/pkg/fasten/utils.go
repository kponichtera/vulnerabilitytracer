package fasten

import (
	"errors"
	"regexp"
	"strings"
)

var (
	ErrMalformedFastenURI    = errors.New("malformed FASTEN URI")
	ErrMalformedCallableName = errors.New("malformed callable name")
)

type JavaClassAndMethodName struct {
	ClassName  string
	MethodName string
}

func ClassAndMethodNameFromCallableName(callableName string) (*JavaClassAndMethodName, error) {
	regex := compileCallableNameRegex()
	if !regex.MatchString(callableName) {
		return nil, ErrMalformedCallableName
	}

	matches := regex.FindStringSubmatch(callableName)

	className := strings.ReplaceAll(matches[regex.SubexpIndex("className")], "::", ".")
	methodName := matches[regex.SubexpIndex("methodName")]

	return &JavaClassAndMethodName{
		ClassName:  className,
		MethodName: methodName,
	}, nil
}

func JavaPackageFromFastenURI(fastenURI string) (string, error) {
	// Try short FASTEN URI
	regex := compileShortFastenURIRegex()
	if regex.MatchString(fastenURI) {
		matches := regex.FindStringSubmatch(fastenURI)

		return matches[regex.SubexpIndex("package")], nil
	}

	// Try full FASTEN URI
	regex = compileFullFastenURIRegex()
	if regex.MatchString(fastenURI) {
		matches := regex.FindStringSubmatch(fastenURI)

		return matches[regex.SubexpIndex("package")], nil
	}

	return "", ErrMalformedFastenURI
}

func compileShortFastenURIRegex() *regexp.Regexp {
	return regexp.MustCompile(`^/(?P<package>(.+))/(.+)$`)
}

func compileFullFastenURIRegex() *regexp.Regexp {
	return regexp.MustCompile(`^fasten://(.+)/(?P<package>(.+))/(.+)$`)
}

func compileCallableNameRegex() *regexp.Regexp {
	return regexp.MustCompile(`^(?P<className>(.+))::(?P<methodName>(.+))$`)
}
