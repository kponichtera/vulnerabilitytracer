-- name: GetServicesForObserving :many
SELECT id, name
FROM service.latest_services;

-- name: InsertTrace :exec
WITH service AS (SELECT id
                 FROM service.latest_services
                 WHERE name = @service_name)
INSERT
INTO trace.traces (tempo_id, service_id, time)
SELECT @tempo_id, service.id, @time
FROM service
ON CONFLICT (tempo_id) DO NOTHING;

-- name: GetTracesToScrape :many
SELECT id, tempo_id, time
FROM trace.traces
WHERE scraped IS FALSE
  AND time > @fromTime
ORDER BY time
LIMIT @batch_size;

-- name: InsertTraceGraphNodes :copyfrom
INSERT INTO trace.trace_graph_nodes (trace_id, span_id, service_name)
VALUES (@trace_id, @span_id, @service_name);

-- name: InsertTraceGraphEdges :copyfrom
INSERT INTO trace.trace_graph_edges (source_trace_id, source_span_id, target_trace_id, target_span_id)
VALUES (@source_trace_id, @source_span_id, @target_trace_id, @target_span_id);

-- name: InsertEvent :exec
WITH service AS (SELECT id
                 FROM service.latest_services
                 WHERE name = @service_name)
INSERT
INTO trace.events (service_id, trace_id, span_id, callable_fasten_id,
                   severity, mitigation_strategy, time, vulnerability_external_id)
SELECT service.id,
       @trace_id,
       @span_id,
       @callable_fasten_id,
       @severity,
       @mitigation_strategy,
       @time,
       @vulnerability_external_id
FROM service;

-- name: SetTracesAsScraped :exec
UPDATE trace.traces
SET scraped = TRUE
WHERE id = ANY (@trace_ids::bigint[]);

-- name: CountUnscrapedTraces :one
SELECT COUNT(id)
FROM trace.traces
WHERE scraped IS FALSE
  AND time > @from_time;