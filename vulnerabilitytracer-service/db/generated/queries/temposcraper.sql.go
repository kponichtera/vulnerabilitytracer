// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: temposcraper.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getServicesForObserving = `-- name: GetServicesForObserving :many
SELECT id, name
FROM service.latest_services
`

type GetServicesForObservingRow struct {
	ID   int64
	Name string
}

func (q *Queries) GetServicesForObserving(ctx context.Context) ([]GetServicesForObservingRow, error) {
	rows, err := q.db.Query(ctx, getServicesForObserving)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetServicesForObservingRow
	for rows.Next() {
		var i GetServicesForObservingRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTracesToScrape = `-- name: GetTracesToScrape :many
SELECT id, tempo_id, time
FROM trace.traces
WHERE scraped IS FALSE
  AND time > $1
ORDER BY time
LIMIT $2
`

type GetTracesToScrapeParams struct {
	Fromtime  pgtype.Timestamptz
	BatchSize int32
}

type GetTracesToScrapeRow struct {
	ID      int64
	TempoID string
	Time    pgtype.Timestamptz
}

func (q *Queries) GetTracesToScrape(ctx context.Context, arg GetTracesToScrapeParams) ([]GetTracesToScrapeRow, error) {
	rows, err := q.db.Query(ctx, getTracesToScrape, arg.Fromtime, arg.BatchSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTracesToScrapeRow
	for rows.Next() {
		var i GetTracesToScrapeRow
		if err := rows.Scan(&i.ID, &i.TempoID, &i.Time); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertTrace = `-- name: InsertTrace :exec
WITH service AS (
    SELECT id
    FROM service.latest_services
    WHERE name = $3
)
INSERT INTO trace.traces (tempo_id, service_id, time)
SELECT $1, service.id, $2
FROM service
ON CONFLICT (tempo_id) DO NOTHING
`

type InsertTraceParams struct {
	TempoID     string
	Time        pgtype.Timestamptz
	ServiceName string
}

func (q *Queries) InsertTrace(ctx context.Context, arg InsertTraceParams) error {
	_, err := q.db.Exec(ctx, insertTrace, arg.TempoID, arg.Time, arg.ServiceName)
	return err
}
