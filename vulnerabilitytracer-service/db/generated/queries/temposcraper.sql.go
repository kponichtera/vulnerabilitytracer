// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: temposcraper.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUnscrapedTraces = `-- name: CountUnscrapedTraces :one
SELECT COUNT(id)
FROM trace.traces
WHERE scraped IS FALSE
  AND time > $1
`

func (q *Queries) CountUnscrapedTraces(ctx context.Context, fromTime pgtype.Timestamptz) (int64, error) {
	row := q.db.QueryRow(ctx, countUnscrapedTraces, fromTime)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getServicesForObserving = `-- name: GetServicesForObserving :many
SELECT id, name
FROM service.latest_services
`

type GetServicesForObservingRow struct {
	ID   int64
	Name string
}

func (q *Queries) GetServicesForObserving(ctx context.Context) ([]GetServicesForObservingRow, error) {
	rows, err := q.db.Query(ctx, getServicesForObserving)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetServicesForObservingRow
	for rows.Next() {
		var i GetServicesForObservingRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTracesToScrape = `-- name: GetTracesToScrape :many
SELECT id, tempo_id, time
FROM trace.traces
WHERE scraped IS FALSE
  AND time > $1
ORDER BY time
LIMIT $2
`

type GetTracesToScrapeParams struct {
	Fromtime  pgtype.Timestamptz
	BatchSize int32
}

type GetTracesToScrapeRow struct {
	ID      int64
	TempoID string
	Time    pgtype.Timestamptz
}

func (q *Queries) GetTracesToScrape(ctx context.Context, arg GetTracesToScrapeParams) ([]GetTracesToScrapeRow, error) {
	rows, err := q.db.Query(ctx, getTracesToScrape, arg.Fromtime, arg.BatchSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTracesToScrapeRow
	for rows.Next() {
		var i GetTracesToScrapeRow
		if err := rows.Scan(&i.ID, &i.TempoID, &i.Time); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertEvent = `-- name: InsertEvent :exec
WITH service AS (SELECT id
                 FROM service.latest_services
                 WHERE name = $8)
INSERT
INTO trace.events (service_id, trace_id, span_id, callable_fasten_id,
                   severity, mitigation_strategy, time, vulnerability_external_id)
SELECT service.id,
       $1,
       $2,
       $3,
       $4,
       $5,
       $6,
       $7
FROM service
`

type InsertEventParams struct {
	TraceID                 int64
	SpanID                  string
	CallableFastenID        string
	Severity                VulnerabilitiesSeverity
	MitigationStrategy      ServiceMitigationStrategyType
	Time                    pgtype.Timestamptz
	VulnerabilityExternalID string
	ServiceName             string
}

func (q *Queries) InsertEvent(ctx context.Context, arg InsertEventParams) error {
	_, err := q.db.Exec(ctx, insertEvent,
		arg.TraceID,
		arg.SpanID,
		arg.CallableFastenID,
		arg.Severity,
		arg.MitigationStrategy,
		arg.Time,
		arg.VulnerabilityExternalID,
		arg.ServiceName,
	)
	return err
}

const insertTrace = `-- name: InsertTrace :exec
WITH service AS (SELECT id
                 FROM service.latest_services
                 WHERE name = $3)
INSERT
INTO trace.traces (tempo_id, service_id, time)
SELECT $1, service.id, $2
FROM service
ON CONFLICT (tempo_id) DO NOTHING
`

type InsertTraceParams struct {
	TempoID     string
	Time        pgtype.Timestamptz
	ServiceName string
}

func (q *Queries) InsertTrace(ctx context.Context, arg InsertTraceParams) error {
	_, err := q.db.Exec(ctx, insertTrace, arg.TempoID, arg.Time, arg.ServiceName)
	return err
}

type InsertTraceGraphEdgesParams struct {
	SourceTraceID int64
	SourceSpanID  string
	TargetTraceID int64
	TargetSpanID  string
}

type InsertTraceGraphNodesParams struct {
	TraceID     int64
	SpanID      string
	ServiceName string
}

const setTracesAsScraped = `-- name: SetTracesAsScraped :exec
UPDATE trace.traces
SET scraped = TRUE
WHERE id = ANY ($1::bigint[])
`

func (q *Queries) SetTracesAsScraped(ctx context.Context, traceIds []int64) error {
	_, err := q.db.Exec(ctx, setTracesAsScraped, traceIds)
	return err
}
