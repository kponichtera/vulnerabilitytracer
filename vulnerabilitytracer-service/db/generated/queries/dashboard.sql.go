// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: dashboard.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const applyMitigationStrategy = `-- name: ApplyMitigationStrategy :exec
INSERT INTO service.mitigation_strategies (service_id, callable_id, strategy)
VALUES ($1, $2, $3)
ON CONFLICT (service_id, callable_id) DO UPDATE SET strategy = $3
`

type ApplyMitigationStrategyParams struct {
	ServiceID  int64
	CallableID int64
	Strategy   ServiceMitigationStrategyType
}

func (q *Queries) ApplyMitigationStrategy(ctx context.Context, arg ApplyMitigationStrategyParams) error {
	_, err := q.db.Exec(ctx, applyMitigationStrategy, arg.ServiceID, arg.CallableID, arg.Strategy)
	return err
}

const getDashboardVulnerabilities = `-- name: GetDashboardVulnerabilities :many
SELECT v.external_id, v.severity, COUNT(e.id) AS trigger_count
FROM vulnerabilities.vulnerabilities v
         LEFT JOIN trace.events e ON v.external_id = e.vulnerability_external_id
    AND e.time > $1 AND e.time < $2
GROUP BY v.external_id, v.severity
ORDER BY v.severity DESC, trigger_count DESC
`

type GetDashboardVulnerabilitiesParams struct {
	FromTime pgtype.Timestamptz
	ToTime   pgtype.Timestamptz
}

type GetDashboardVulnerabilitiesRow struct {
	ExternalID   string
	Severity     VulnerabilitiesSeverity
	TriggerCount int64
}

func (q *Queries) GetDashboardVulnerabilities(ctx context.Context, arg GetDashboardVulnerabilitiesParams) ([]GetDashboardVulnerabilitiesRow, error) {
	rows, err := q.db.Query(ctx, getDashboardVulnerabilities, arg.FromTime, arg.ToTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDashboardVulnerabilitiesRow
	for rows.Next() {
		var i GetDashboardVulnerabilitiesRow
		if err := rows.Scan(&i.ExternalID, &i.Severity, &i.TriggerCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getImpactGraphEdges = `-- name: GetImpactGraphEdges :many
WITH RECURSIVE
    vulnerable_nodes AS (
        -- Base case: Nodes directly associated with the specified vulnerability
        SELECT e.trace_id, e.span_id, e.vulnerability_external_id
        FROM trace.traces t
                 JOIN trace.events e ON t.id = e.trace_id
        WHERE t.time > $1
          AND t.time < $2),
    reachable_nodes(trace_id, span_id, is_reachable) AS (
        -- Initial selection of vulnerable nodes
        SELECT trace_id, span_id, TRUE AS is_reachable
        FROM vulnerable_nodes
        WHERE vulnerability_external_id = $3

        UNION ALL

        -- Recursive part: Find nodes leading to already identified reachable nodes
        SELECT e.source_trace_id, e.source_span_id, TRUE AS is_reachable
        FROM trace.trace_graph_edges e
                 JOIN reachable_nodes rn ON e.target_trace_id = rn.trace_id AND e.target_span_id = rn.span_id
                 JOIN trace.traces t ON e.source_trace_id = t.id
        WHERE t.time > $1
          AND t.time < $2),
    edges_with_reachability AS (SELECT e.source_trace_id,
                                       e.source_span_id,
                                       e.target_trace_id,
                                       e.target_span_id,
                                       -- Check if target node is marked as reachable
                                       -- TODO: Not enough edges are marked as vulnerable
                                       COALESCE(rn_target.is_reachable, FALSE) AS leads_to_vulnerability
                                FROM trace.trace_graph_edges e
                                         LEFT JOIN reachable_nodes rn_target
                                                   ON e.target_trace_id = rn_target.trace_id AND
                                                      e.target_span_id = rn_target.span_id
                                         JOIN trace.traces t ON e.source_trace_id = t.id
                                WHERE t.time > $1
                                  AND t.time < $2)
SELECT source_trace_id, source_span_id, target_trace_id, target_span_id, leads_to_vulnerability
FROM edges_with_reachability
`

type GetImpactGraphEdgesParams struct {
	FromTime                pgtype.Timestamptz
	ToTime                  pgtype.Timestamptz
	VulnerabilityExternalID string
}

type GetImpactGraphEdgesRow struct {
	SourceTraceID        int64
	SourceSpanID         string
	TargetTraceID        int64
	TargetSpanID         string
	LeadsToVulnerability bool
}

func (q *Queries) GetImpactGraphEdges(ctx context.Context, arg GetImpactGraphEdgesParams) ([]GetImpactGraphEdgesRow, error) {
	rows, err := q.db.Query(ctx, getImpactGraphEdges, arg.FromTime, arg.ToTime, arg.VulnerabilityExternalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetImpactGraphEdgesRow
	for rows.Next() {
		var i GetImpactGraphEdgesRow
		if err := rows.Scan(
			&i.SourceTraceID,
			&i.SourceSpanID,
			&i.TargetTraceID,
			&i.TargetSpanID,
			&i.LeadsToVulnerability,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getImpactGraphNodes = `-- name: GetImpactGraphNodes :many
WITH RECURSIVE
    vulnerable_nodes AS (
        -- Base case: Nodes directly associated with the specified vulnerability
        SELECT e.trace_id, e.span_id, e.vulnerability_external_id, tn.service_name, e.id AS event_id
        FROM trace.traces t
                 JOIN trace.events e ON t.id = e.trace_id
                 JOIN trace.trace_graph_nodes tn ON e.trace_id = tn.trace_id AND e.span_id = tn.span_id
        WHERE t.time > $1
          AND t.time < $2),
    reachable_nodes(trace_id, span_id, service_name, vulnerability_trigger_count) AS (
        -- Initial selection of vulnerable nodes
        SELECT trace_id, span_id, service_name, COUNT(event_id) AS vulnerability_trigger_count
        FROM vulnerable_nodes
        WHERE vulnerability_external_id = $3
        GROUP BY trace_id, span_id, service_name

        UNION ALL

        -- Recursive part: Find nodes leading to already identified reachable nodes
        SELECT e.source_trace_id, e.source_span_id, tn.service_name, 0 AS vulnerability_trigger_count
        FROM trace.trace_graph_edges e
                 JOIN reachable_nodes rn ON e.target_trace_id = rn.trace_id AND e.target_span_id = rn.span_id
                 INNER JOIN trace.traces t ON e.source_trace_id = t.id
                 INNER JOIN trace.trace_graph_nodes tn ON e.source_trace_id = tn.trace_id AND e.source_span_id = tn.span_id
        WHERE t.time > $1
          AND t.time < $2)
SELECT trace_id, span_id, service_name, vulnerability_trigger_count
FROM reachable_nodes

UNION

SELECT tn.trace_id, tn.span_id, tn.service_name, 0 AS vulnerability_trigger_count
FROM trace.trace_graph_nodes tn
         JOIN trace.traces t ON tn.trace_id = t.id
WHERE t.time > $1
  AND t.time < $2
  AND tn.service_name IN (SELECT DISTINCT service_name FROM reachable_nodes)
  AND tn.trace_id NOT IN (SELECT trace_id FROM reachable_nodes)
`

type GetImpactGraphNodesParams struct {
	FromTime                pgtype.Timestamptz
	ToTime                  pgtype.Timestamptz
	VulnerabilityExternalID string
}

type GetImpactGraphNodesRow struct {
	TraceID                   int64
	SpanID                    string
	ServiceName               string
	VulnerabilityTriggerCount int64
}

func (q *Queries) GetImpactGraphNodes(ctx context.Context, arg GetImpactGraphNodesParams) ([]GetImpactGraphNodesRow, error) {
	rows, err := q.db.Query(ctx, getImpactGraphNodes, arg.FromTime, arg.ToTime, arg.VulnerabilityExternalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetImpactGraphNodesRow
	for rows.Next() {
		var i GetImpactGraphNodesRow
		if err := rows.Scan(
			&i.TraceID,
			&i.SpanID,
			&i.ServiceName,
			&i.VulnerabilityTriggerCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceMitigations = `-- name: GetServiceMitigations :many
WITH service_dependencies AS (SELECT s.id           AS service_id,
                                     s.name         AS service_name,
                                     d.group_id     AS dependency_group_id,
                                     d.artifact_id  AS dependency_artifact_id,
                                     d.version      AS dependency_version,
                                     c.id           AS callable_id,
                                     c.package_name AS callable_package_name,
                                     c.class_name   AS callable_class_name,
                                     c.method_name  AS callable_method_name
                              FROM vulnerabilities.vulnerabilities v
                                       JOIN java.dependencies_vulnerabilities dv ON v.id = dv.vulnerability_id
                                       JOIN java.dependencies d ON dv.dependency_id = d.id
                                       JOIN service.service_dependencies sd ON d.id = sd.dependency_id
                                       JOIN service.services s ON sd.service_id = s.id
                                       JOIN java.callables_vulnerabilities cv ON v.id = cv.vulnerability_id
                                       JOIN java.callables c ON cv.callable_id = c.id
                              WHERE v.external_id = $1),
     mitigations AS (SELECT sd.service_id, ms.callable_id, ms.strategy AS mitigation_strategy
                     FROM service_dependencies sd
                              LEFT JOIN service.mitigation_strategies ms ON sd.service_id = ms.service_id),
     nonmitigated_trigger_count AS (SELECT e.service_id, c.id AS callable_id, COUNT(e.id) AS trigger_count
                                    FROM java.callables c
                                             JOIN trace.events e ON e.callable_fasten_id = c.fasten_id
                                        AND e.time > $2 AND e.time < $3
                                        AND e.mitigation_strategy = 'NONE'
                                    GROUP BY e.service_id, c.id),
     mitigated_trigger_count AS (SELECT e.service_id, c.id AS callable_id, COUNT(e.id) AS trigger_count
                                 FROM java.callables c
                                          JOIN trace.events e ON e.callable_fasten_id = c.fasten_id
                                     AND e.time > $2 AND e.time < $3
                                     AND e.mitigation_strategy <> 'NONE'
                                 GROUP BY e.service_id, c.id)
SELECT sd.service_id,
       sd.service_name,
       sd.dependency_group_id,
       sd.dependency_artifact_id,
       sd.dependency_version,
       sd.callable_id,
       sd.callable_package_name,
       sd.callable_class_name,
       sd.callable_method_name,
       COALESCE(m.mitigation_strategy, 'NONE') AS mitigation_strategy,
       COALESCE(nmtc.trigger_count, 0)         AS nonmitigated_trigger_count,
       COALESCE(mtc.trigger_count, 0)          AS mitigated_trigger_count
FROM service_dependencies sd
         LEFT JOIN mitigations m
                   ON m.service_id = sd.service_id AND m.callable_id = sd.callable_id
         LEFT JOIN nonmitigated_trigger_count nmtc
                   ON nmtc.service_id = sd.service_id AND nmtc.callable_id = sd.callable_id
         LEFT JOIN mitigated_trigger_count mtc
                   ON mtc.service_id = sd.service_id AND mtc.callable_id = sd.callable_id
`

type GetServiceMitigationsParams struct {
	VulnerabilityExternalID string
	FromTime                pgtype.Timestamptz
	ToTime                  pgtype.Timestamptz
}

type GetServiceMitigationsRow struct {
	ServiceID                int64
	ServiceName              string
	DependencyGroupID        string
	DependencyArtifactID     string
	DependencyVersion        string
	CallableID               int64
	CallablePackageName      string
	CallableClassName        string
	CallableMethodName       string
	MitigationStrategy       ServiceMitigationStrategyType
	NonmitigatedTriggerCount int64
	MitigatedTriggerCount    int64
}

func (q *Queries) GetServiceMitigations(ctx context.Context, arg GetServiceMitigationsParams) ([]GetServiceMitigationsRow, error) {
	rows, err := q.db.Query(ctx, getServiceMitigations, arg.VulnerabilityExternalID, arg.FromTime, arg.ToTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetServiceMitigationsRow
	for rows.Next() {
		var i GetServiceMitigationsRow
		if err := rows.Scan(
			&i.ServiceID,
			&i.ServiceName,
			&i.DependencyGroupID,
			&i.DependencyArtifactID,
			&i.DependencyVersion,
			&i.CallableID,
			&i.CallablePackageName,
			&i.CallableClassName,
			&i.CallableMethodName,
			&i.MitigationStrategy,
			&i.NonmitigatedTriggerCount,
			&i.MitigatedTriggerCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVulnerabilityServices = `-- name: GetVulnerabilityServices :many
WITH service_dependencies AS (SELECT s.id AS service_id, s.name AS service_name, d.group_id, d.artifact_id, d.version
                              FROM vulnerabilities.vulnerabilities v
                                       JOIN java.dependencies_vulnerabilities dv ON v.id = dv.vulnerability_id
                                       JOIN java.dependencies d ON dv.dependency_id = d.id
                                       JOIN service.service_dependencies sd ON d.id = sd.dependency_id
                                       JOIN service.services s ON sd.service_id = s.id
                              WHERE v.external_id = $1),
     enabled_mitigations AS (SELECT sd.service_id, COUNT(ms.service_id) AS mitigation_count
                             FROM service_dependencies sd
                                      LEFT JOIN service.mitigation_strategies ms ON sd.service_id = ms.service_id
                                 AND ms.strategy != 'NONE'
                             GROUP BY sd.service_id),
     trigger_count AS (SELECT sd.service_id, COUNT(e.id) AS trigger_count
                       FROM service_dependencies sd
                                LEFT JOIN trace.events e
                                          ON sd.service_id = e.service_id
                                              AND e.time > $2 AND e.time < $3
                                              AND e.vulnerability_external_id = $1
                       GROUP BY sd.service_id)
SELECT sd.service_id,
       sd.service_name,
       sd.group_id,
       sd.artifact_id,
       sd.version,
       em.mitigation_count,
       tc.trigger_count
FROM service_dependencies sd
         JOIN enabled_mitigations em ON sd.service_id = em.service_id
         JOIN trigger_count tc ON sd.service_id = tc.service_id
`

type GetVulnerabilityServicesParams struct {
	VulnerabilityExternalID string
	FromTime                pgtype.Timestamptz
	ToTime                  pgtype.Timestamptz
}

type GetVulnerabilityServicesRow struct {
	ServiceID       int64
	ServiceName     string
	GroupID         string
	ArtifactID      string
	Version         string
	MitigationCount int64
	TriggerCount    int64
}

func (q *Queries) GetVulnerabilityServices(ctx context.Context, arg GetVulnerabilityServicesParams) ([]GetVulnerabilityServicesRow, error) {
	rows, err := q.db.Query(ctx, getVulnerabilityServices, arg.VulnerabilityExternalID, arg.FromTime, arg.ToTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVulnerabilityServicesRow
	for rows.Next() {
		var i GetVulnerabilityServicesRow
		if err := rows.Scan(
			&i.ServiceID,
			&i.ServiceName,
			&i.GroupID,
			&i.ArtifactID,
			&i.Version,
			&i.MitigationCount,
			&i.TriggerCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
