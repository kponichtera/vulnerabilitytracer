package main

import (
	"flag"

	"vulnerabilitytracer/internal/config"
	"vulnerabilitytracer/internal/processor"
	"vulnerabilitytracer/internal/processor/vulnerabilityupdaterprocessor"
	"vulnerabilitytracer/internal/runtime"

	"github.com/sirupsen/logrus"
)

const DefaultPort = 10422

//nolint:gochecknoglobals
var (
	port        = flag.Int("port", DefaultPort, "HTTP server port (when running as a server)")
	configFile  = flag.String("config-file", "config.yaml", "Path to YAML configuration file")
	displayHelp = flag.Bool("help", false, "Display configuration")
	server      = flag.Bool("server", false, "Run as a server with background scheduler (default: run once)")
)

func main() {
	flag.Parse()

	var appConfig vulnerabilityupdaterprocessor.Config
	if *displayHelp {
		config.PrintHelpAndExit(appConfig)
	}

	config.Read(*configFile, &appConfig)
	logrus.SetLevel(appConfig.Log.Level)

	runtimeCtx, err := runtime.Build(appConfig.Fasten, appConfig.Database)
	if err != nil {
		logrus.WithError(err).Fatal("error when building runtime context")
	}
	defer runtimeCtx.Close()

	if *server {
		sched, err := processor.RunScheduler(*runtimeCtx, appConfig.Processor, appConfig, vulnerabilityupdaterprocessor.Run)
		if err != nil {
			logrus.WithError(err).Fatal("error when starting processor job scheduler")
		}
		defer sched.Stop()

		if err := processor.RunServer(port, *runtimeCtx); err != nil {
			logrus.WithError(err).Fatal("server runtime error")
		}
	} else {
		if err := processor.RunOnce(*runtimeCtx, appConfig.Processor, appConfig, vulnerabilityupdaterprocessor.Run); err != nil {
			logrus.WithError(err).Fatal("error when running processor job")
		}
	}
}
