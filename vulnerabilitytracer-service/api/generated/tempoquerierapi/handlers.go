// Package tempoquerierapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.2 DO NOT EDIT.
package tempoquerierapi

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// Defines values for SpanSpanKind.
const (
	SPANKINDCLIENT      SpanSpanKind = "SPAN_KIND_CLIENT"
	SPANKINDCONSUMER    SpanSpanKind = "SPAN_KIND_CONSUMER"
	SPANKINDINTERNAL    SpanSpanKind = "SPAN_KIND_INTERNAL"
	SPANKINDPRODUCER    SpanSpanKind = "SPAN_KIND_PRODUCER"
	SPANKINDSERVER      SpanSpanKind = "SPAN_KIND_SERVER"
	SPANKINDUNSPECIFIED SpanSpanKind = "SPAN_KIND_UNSPECIFIED"
)

// Defines values for StatusStatusCode.
const (
	STATUSCODEERROR StatusStatusCode = "STATUS_CODE_ERROR"
	STATUSCODEOK    StatusStatusCode = "STATUS_CODE_OK"
	STATUSCODEUNSET StatusStatusCode = "STATUS_CODE_UNSET"
)

// SpanEvent Event is a time-stamped annotation of the span, consisting of user-supplied
// text description and key-value pairs.
type SpanEvent struct {
	// Attributes attributes is a collection of attribute key/value pairs on the event.
	// Attribute keys MUST be unique (it is not allowed to have more than one
	// attribute with the same key).
	Attributes *[]V1KeyValue `json:"attributes,omitempty"`

	// DroppedAttributesCount dropped_attributes_count is the number of dropped attributes. If the value is 0,
	// then no attributes were dropped.
	DroppedAttributesCount *int64 `json:"droppedAttributesCount,omitempty"`

	// Name name of the event.
	// This field is semantically required to be set to non-empty string.
	Name *string `json:"name,omitempty"`

	// TimeUnixNano time_unix_nano is the time the event occurred.
	TimeUnixNano *string `json:"timeUnixNano,omitempty"`
}

// SpanLink A pointer from the current span to another span in the same trace or in a
// different trace. For example, this can be used in batching operations,
// where a single batch handler processes multiple requests from different
// traces or when the handler receives a request from a different project.
type SpanLink struct {
	// Attributes attributes is a collection of attribute key/value pairs on the link.
	// Attribute keys MUST be unique (it is not allowed to have more than one
	// attribute with the same key).
	Attributes *[]V1KeyValue `json:"attributes,omitempty"`

	// DroppedAttributesCount dropped_attributes_count is the number of dropped attributes. If the value is 0,
	// then no attributes were dropped.
	DroppedAttributesCount *int64 `json:"droppedAttributesCount,omitempty"`

	// Flags Flags, a bit field.
	//
	// Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
	// Context specification. To read the 8-bit W3C trace flag, use
	// `flags & SPAN_FLAGS_TRACE_FLAGS_MASK`.
	//
	// See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
	//
	// Bits 8 and 9 represent the 3 states of whether the link is remote.
	// The states are (unknown, is not remote, is remote).
	// To read whether the value is known, use `(flags & SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
	// To read whether the link is remote, use `(flags & SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
	//
	// Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
	// When creating new spans, bits 10-31 (most-significant 22-bits) MUST be zero.
	//
	// [Optional].
	Flags *int64 `json:"flags,omitempty"`

	// SpanId A unique identifier for the linked span. The ID is an 8-byte array.
	SpanId *[]byte `json:"spanId,omitempty"`

	// TraceId A unique identifier of a trace that this linked span is part of. The ID is a
	// 16-byte array.
	TraceId *[]byte `json:"traceId,omitempty"`

	// TraceState The trace_state associated with the link.
	TraceState *string `json:"traceState,omitempty"`
}

// SpanSpanKind SpanKind is the type of span. Can be used to specify additional relationships between spans
// in addition to a parent/child relationship.
//
//   - SPAN_KIND_UNSPECIFIED: Unspecified. Do NOT use as default.
//
// Implementations MAY assume SpanKind to be INTERNAL when receiving UNSPECIFIED.
//   - SPAN_KIND_INTERNAL: Indicates that the span represents an internal operation within an application,
//
// as opposed to an operation happening at the boundaries. Default value.
//   - SPAN_KIND_SERVER: Indicates that the span covers server-side handling of an RPC or other
//
// remote network request.
//   - SPAN_KIND_CLIENT: Indicates that the span describes a request to some remote service.
//   - SPAN_KIND_PRODUCER: Indicates that the span describes a producer sending a message to a broker.
//
// Unlike CLIENT and SERVER, there is often no direct critical path latency relationship
// between producer and consumer spans. A PRODUCER span ends when the message was accepted
// by the broker while the logical processing of the message might span a much longer time.
//   - SPAN_KIND_CONSUMER: Indicates that the span describes consumer receiving a message from a broker.
//
// Like the PRODUCER kind, there is often no direct critical path latency relationship
// between producer and consumer spans.
type SpanSpanKind string

// StatusStatusCode - STATUS_CODE_UNSET: The default status.
//   - STATUS_CODE_OK: The Span has been validated by an Application developer or Operator to
//
// have completed successfully.
//   - STATUS_CODE_ERROR: The Span contains an error.
type StatusStatusCode string

// TraceQueryResponseBatch defines model for TraceQueryResponseBatch.
type TraceQueryResponseBatch struct {
	// Resource Resource information.
	Resource *V1Resource `json:"resource,omitempty"`

	// ScopeSpans A collection of Spans produced by an InstrumentationScope.
	ScopeSpans *V1ScopeSpans `json:"scopeSpans,omitempty"`
}

// TraceQueryResponsePayload defines model for TraceQueryResponsePayload.
type TraceQueryResponsePayload struct {
	Batches *[]TraceQueryResponseBatch `json:"batches,omitempty"`
}

// TraceSearchMetrics defines model for TraceSearchMetrics.
type TraceSearchMetrics struct {
	CompletedJobs   *int    `json:"completedJobs,omitempty"`
	InspectedBytes  *string `json:"inspectedBytes,omitempty"`
	InspectedTraces *int    `json:"inspectedTraces,omitempty"`
	TotalJobs       *int    `json:"totalJobs,omitempty"`
}

// TraceSearchResponsePayload defines model for TraceSearchResponsePayload.
type TraceSearchResponsePayload struct {
	Metrics *TraceSearchMetrics  `json:"metrics,omitempty"`
	Traces  *[]TraceSearchResult `json:"traces,omitempty"`
}

// TraceSearchResult defines model for TraceSearchResult.
type TraceSearchResult struct {
	DurationMs        *int    `json:"durationMs,omitempty"`
	RootServiceName   *string `json:"rootServiceName,omitempty"`
	RootTraceName     *string `json:"rootTraceName,omitempty"`
	StartTimeUnixNano *string `json:"startTimeUnixNano,omitempty"`
	TraceID           *string `json:"traceID,omitempty"`
}

// Tracev1Status The Status type defines a logical error model that is suitable for different
// programming environments, including REST APIs and RPC APIs.
type Tracev1Status struct {
	// Code - STATUS_CODE_UNSET: The default status.
	//  - STATUS_CODE_OK: The Span has been validated by an Application developer or Operator to
	// have completed successfully.
	//  - STATUS_CODE_ERROR: The Span contains an error.
	Code *StatusStatusCode `json:"code,omitempty"`

	// Message A developer-facing human readable error message.
	Message *string `json:"message,omitempty"`
}

// V1AnyValue AnyValue is used to represent any type of attribute value. AnyValue may contain a
// primitive value such as a string or integer or it may contain an arbitrary nested
// object containing arrays, key-value lists and primitives.
type V1AnyValue struct {
	// ArrayValue ArrayValue is a list of AnyValue messages. We need ArrayValue as a message
	// since oneof in AnyValue does not allow repeated fields.
	ArrayValue  *V1ArrayValue   `json:"arrayValue,omitempty"`
	BoolValue   *bool           `json:"boolValue,omitempty"`
	BytesValue  *[]byte         `json:"bytesValue,omitempty"`
	DoubleValue *float64        `json:"doubleValue,omitempty"`
	IntValue    *string         `json:"intValue,omitempty"`
	KvlistValue *V1KeyValueList `json:"kvlistValue,omitempty"`
	StringValue *string         `json:"stringValue,omitempty"`
}

// V1ArrayValue ArrayValue is a list of AnyValue messages. We need ArrayValue as a message
// since oneof in AnyValue does not allow repeated fields.
type V1ArrayValue struct {
	// Values Array of values. The array may be empty (contain 0 elements).
	Values *[]V1AnyValue `json:"values,omitempty"`
}

// V1InstrumentationScope InstrumentationScope is a message representing the instrumentation scope information
// such as the fully qualified name and version.
type V1InstrumentationScope struct {
	// Attributes Additional attributes that describe the scope. [Optional].
	// Attribute keys MUST be unique (it is not allowed to have more than one
	// attribute with the same key).
	Attributes             *[]V1KeyValue `json:"attributes,omitempty"`
	DroppedAttributesCount *int64        `json:"droppedAttributesCount,omitempty"`

	// Name An empty instrumentation scope name means the name is unknown.
	Name    *string `json:"name,omitempty"`
	Version *string `json:"version,omitempty"`
}

// V1KeyValue KeyValue is a key-value pair that is used to store Span attributes, Link
// attributes, etc.
type V1KeyValue struct {
	Key *string `json:"key,omitempty"`

	// Value AnyValue is used to represent any type of attribute value. AnyValue may contain a
	// primitive value such as a string or integer or it may contain an arbitrary nested
	// object containing arrays, key-value lists and primitives.
	Value *V1AnyValue `json:"value,omitempty"`
}

// V1KeyValueList defines model for v1KeyValueList.
type V1KeyValueList struct {
	// Values A collection of key/value pairs of key-value pairs. The list may be empty (may
	// contain 0 elements).
	// The keys MUST be unique (it is not allowed to have more than one
	// value with the same key).
	Values *[]V1KeyValue `json:"values,omitempty"`
}

// V1Resource Resource information.
type V1Resource struct {
	// Attributes Set of attributes that describe the resource.
	// Attribute keys MUST be unique (it is not allowed to have more than one
	// attribute with the same key).
	Attributes *[]V1KeyValue `json:"attributes,omitempty"`

	// DroppedAttributesCount dropped_attributes_count is the number of dropped attributes. If the value is 0, then
	// no attributes were dropped.
	DroppedAttributesCount *int64 `json:"droppedAttributesCount,omitempty"`
}

// V1ScopeSpans A collection of Spans produced by an InstrumentationScope.
type V1ScopeSpans struct {
	// SchemaUrl The Schema URL, if known. This is the identifier of the Schema that the span data
	// is recorded in. To learn more about Schema URL see
	// https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
	// This schema_url applies to all spans and span events in the "spans" field.
	SchemaUrl *string `json:"schemaUrl,omitempty"`

	// Scope InstrumentationScope is a message representing the instrumentation scope information
	// such as the fully qualified name and version.
	Scope *V1InstrumentationScope `json:"scope,omitempty"`

	// Spans A list of Spans that originate from an instrumentation scope.
	Spans *[]V1Span `json:"spans,omitempty"`
}

// V1Span A Span represents a single operation performed by a single component of the system.
//
// The next available field id is 17.
type V1Span struct {
	// Attributes "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
	//     "/http/server_latency": 300
	//     "example.com/myattribute": true
	//     "example.com/score": 10.239
	//
	// The OpenTelemetry API specification further restricts the allowed value types:
	// https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/README.md#attribute
	// Attribute keys MUST be unique (it is not allowed to have more than one
	// attribute with the same key).
	Attributes *[]V1KeyValue `json:"attributes,omitempty"`

	// DroppedAttributesCount dropped_attributes_count is the number of attributes that were discarded. Attributes
	// can be discarded because their keys are too long or because there are too many
	// attributes. If this value is 0, then no attributes were dropped.
	DroppedAttributesCount *int64 `json:"droppedAttributesCount,omitempty"`

	// DroppedEventsCount dropped_events_count is the number of dropped events. If the value is 0, then no
	// events were dropped.
	DroppedEventsCount *int64 `json:"droppedEventsCount,omitempty"`

	// DroppedLinksCount dropped_links_count is the number of dropped links after the maximum size was
	// enforced. If this value is 0, then no links were dropped.
	DroppedLinksCount *int64 `json:"droppedLinksCount,omitempty"`

	// EndTimeUnixNano end_time_unix_nano is the end time of the span. On the client side, this is the time
	// kept by the local machine where the span execution ends. On the server side, this
	// is the time when the server application handler stops running.
	// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
	//
	// This field is semantically required and it is expected that end_time >= start_time.
	EndTimeUnixNano *string `json:"endTimeUnixNano,omitempty"`

	// Events events is a collection of Event items.
	Events *[]SpanEvent `json:"events,omitempty"`

	// Flags Flags, a bit field.
	//
	// Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
	// Context specification. To read the 8-bit W3C trace flag, use
	// `flags & SPAN_FLAGS_TRACE_FLAGS_MASK`.
	//
	// See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
	//
	// Bits 8 and 9 represent the 3 states of whether a span's parent
	// is remote. The states are (unknown, is not remote, is remote).
	// To read whether the value is known, use `(flags & SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
	// To read whether the span is remote, use `(flags & SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
	//
	// When creating span messages, if the message is logically forwarded from another source
	// with an equivalent flags fields (i.e., usually another OTLP span message), the field SHOULD
	// be copied as-is. If creating from a source that does not have an equivalent flags field
	// (such as a runtime representation of an OpenTelemetry span), the high 22 bits MUST
	// be set to zero.
	// Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
	//
	// [Optional].
	Flags *int64 `json:"flags,omitempty"`

	// Kind SpanKind is the type of span. Can be used to specify additional relationships between spans
	// in addition to a parent/child relationship.
	//
	//  - SPAN_KIND_UNSPECIFIED: Unspecified. Do NOT use as default.
	// Implementations MAY assume SpanKind to be INTERNAL when receiving UNSPECIFIED.
	//  - SPAN_KIND_INTERNAL: Indicates that the span represents an internal operation within an application,
	// as opposed to an operation happening at the boundaries. Default value.
	//  - SPAN_KIND_SERVER: Indicates that the span covers server-side handling of an RPC or other
	// remote network request.
	//  - SPAN_KIND_CLIENT: Indicates that the span describes a request to some remote service.
	//  - SPAN_KIND_PRODUCER: Indicates that the span describes a producer sending a message to a broker.
	// Unlike CLIENT and SERVER, there is often no direct critical path latency relationship
	// between producer and consumer spans. A PRODUCER span ends when the message was accepted
	// by the broker while the logical processing of the message might span a much longer time.
	//  - SPAN_KIND_CONSUMER: Indicates that the span describes consumer receiving a message from a broker.
	// Like the PRODUCER kind, there is often no direct critical path latency relationship
	// between producer and consumer spans.
	Kind *SpanSpanKind `json:"kind,omitempty"`

	// Links links is a collection of Links, which are references from this span to a span
	// in the same or different trace.
	Links *[]SpanLink `json:"links,omitempty"`

	// Name A description of the span's operation.
	//
	// For example, the name can be a qualified method name or a file name
	// and a line number where the operation is called. A best practice is to use
	// the same display name at the same call point in an application.
	// This makes it easier to correlate spans in different traces.
	//
	// This field is semantically required to be set to non-empty string.
	// Empty value is equivalent to an unknown span name.
	//
	// This field is required.
	Name *string `json:"name,omitempty"`

	// ParentSpanId The `span_id` of this span's parent span. If this is a root span, then this
	// field must be empty. The ID is an 8-byte array.
	ParentSpanId *[]byte `json:"parentSpanId,omitempty"`

	// SpanId A unique identifier for a span within a trace, assigned when the span
	// is created. The ID is an 8-byte array. An ID with all zeroes OR of length
	// other than 8 bytes is considered invalid (empty string in OTLP/JSON
	// is zero-length and thus is also invalid).
	//
	// This field is required.
	SpanId *[]byte `json:"spanId,omitempty"`

	// StartTimeUnixNano start_time_unix_nano is the start time of the span. On the client side, this is the time
	// kept by the local machine where the span execution starts. On the server side, this
	// is the time when the server's application handler starts running.
	// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
	//
	// This field is semantically required and it is expected that end_time >= start_time.
	StartTimeUnixNano *string `json:"startTimeUnixNano,omitempty"`

	// Status The Status type defines a logical error model that is suitable for different
	// programming environments, including REST APIs and RPC APIs.
	Status *Tracev1Status `json:"status,omitempty"`

	// TraceId A unique identifier for a trace. All spans from the same trace share
	// the same `trace_id`. The ID is a 16-byte array. An ID with all zeroes OR
	// of length other than 16 bytes is considered invalid (empty string in OTLP/JSON
	// is zero-length and thus is also invalid).
	//
	// This field is required.
	TraceId *[]byte `json:"traceId,omitempty"`

	// TraceState trace_state conveys information about request position in multiple distributed tracing graphs.
	// It is a trace_state in w3c-trace-context format: https://www.w3.org/TR/trace-context/#tracestate-header
	// See also https://github.com/w3c/distributed-tracing for more details about this field.
	TraceState *string `json:"traceState,omitempty"`
}

// TraceSearchParams defines parameters for TraceSearch.
type TraceSearchParams struct {
	// Tags logfmt encoding of any span-level or process-level attributes to filter on.  The value is matched as a case-insensitive substring. Key-value pairs are separated by spaces.  If a value contains a space, it should be enclosed within double quotes.
	Tags string `form:"tags" json:"tags"`

	// Start Optional. Along with end define a time range from which traces should be returned. Provide as UNIX epoch seconds.
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// End Optional. Along with start define a time range from which traces should be returned.  Providing both start and end will include blocks for the specified time range only. Provide as UNIX epoch seconds.
	End *int `form:"end,omitempty" json:"end,omitempty"`
}

// TraceQueryParams defines parameters for TraceQuery.
type TraceQueryParams struct {
	// Start Optional. Along with end define a time range from which traces should be returned. Provide as UNIX epoch seconds.
	Start *int `form:"start,omitempty" json:"start,omitempty"`

	// End Optional. Along with start define a time range from which traces should be returned.  Providing both start and end will include traces for the specified time range only.  If the parameters are not provided then Tempo will check for the trace across all blocks in backend.  If the parameters are provided, it will only check in the blocks within the specified time range,  this can result in trace not being found or partial results if it does not fall in the specified time range. Provide as UNIX epoch seconds.
	End *int `form:"end,omitempty" json:"end,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// TraceSearch request
	TraceSearch(ctx context.Context, params *TraceSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TraceQuery request
	TraceQuery(ctx context.Context, traceId string, params *TraceQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) TraceSearch(ctx context.Context, params *TraceSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTraceSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TraceQuery(ctx context.Context, traceId string, params *TraceQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTraceQueryRequest(c.Server, traceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewTraceSearchRequest generates requests for TraceSearch
func NewTraceSearchRequest(server string, params *TraceSearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, params.Tags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTraceQueryRequest generates requests for TraceQuery
func NewTraceQueryRequest(server string, traceId string, params *TraceQueryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "traceId", runtime.ParamLocationPath, traceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/traces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// TraceSearchWithResponse request
	TraceSearchWithResponse(ctx context.Context, params *TraceSearchParams, reqEditors ...RequestEditorFn) (*TraceSearchResponse, error)

	// TraceQueryWithResponse request
	TraceQueryWithResponse(ctx context.Context, traceId string, params *TraceQueryParams, reqEditors ...RequestEditorFn) (*TraceQueryResponse, error)
}

type TraceSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TraceSearchResponsePayload
}

// Status returns HTTPResponse.Status
func (r TraceSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TraceSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TraceQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TraceQueryResponsePayload
}

// Status returns HTTPResponse.Status
func (r TraceQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TraceQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// TraceSearchWithResponse request returning *TraceSearchResponse
func (c *ClientWithResponses) TraceSearchWithResponse(ctx context.Context, params *TraceSearchParams, reqEditors ...RequestEditorFn) (*TraceSearchResponse, error) {
	rsp, err := c.TraceSearch(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTraceSearchResponse(rsp)
}

// TraceQueryWithResponse request returning *TraceQueryResponse
func (c *ClientWithResponses) TraceQueryWithResponse(ctx context.Context, traceId string, params *TraceQueryParams, reqEditors ...RequestEditorFn) (*TraceQueryResponse, error) {
	rsp, err := c.TraceQuery(ctx, traceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTraceQueryResponse(rsp)
}

// ParseTraceSearchResponse parses an HTTP response from a TraceSearchWithResponse call
func ParseTraceSearchResponse(rsp *http.Response) (*TraceSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TraceSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TraceSearchResponsePayload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTraceQueryResponse parses an HTTP response from a TraceQueryWithResponse call
func ParseTraceQueryResponse(rsp *http.Response) (*TraceQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TraceQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TraceQueryResponsePayload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
