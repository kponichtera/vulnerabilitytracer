package nl.tudelft.kponichtera.thesis.vulnerabilitytracer.utils;

import io.opentelemetry.api.common.AttributeKey;
import io.opentelemetry.api.common.Attributes;
import io.opentelemetry.api.common.AttributesBuilder;
import io.opentelemetry.api.trace.Span;
import io.opentelemetry.context.Context;
import io.opentelemetry.context.Scope;
import io.opentelemetry.sdk.internal.AttributesMap;
import lombok.experimental.UtilityClass;
import lombok.extern.java.Log;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.helper.VulnerabilityHolderHelper;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.report.VulnerableCallable;

import java.io.IOException;

@Log
@UtilityClass
public class AdviceUtils {

    private static final String EVENT_NAME = "vulnerability-triggered";

    public static void onEnter(String methodName, String typeName,
                               Context context, Scope scope) throws IOException {
        log.info(String.format("Method entered: %s.%s", typeName, methodName));

        var vulnerabilityHolder = VulnerabilityHolderHelper.getStaticHolder();

        var vulnerableCallables = vulnerabilityHolder.getCallablesForType(typeName);
        if (vulnerableCallables.isEmpty()) {
            log.warning(String.format("No type %s in vulnerability holder", typeName));
            return;
        }

        // Map method name, returned by OpenTelemetry, to the FASTEN format,
        // before searching for the method in the vulnerability holder
        var fastenMethodName = ReportUtils.fromOpentelemetryToFastenMethodName(typeName, methodName);

        // TODO: Full method signature not taken into account, the first one is taken.
        //  Extend the search to compare parameter types as well
        var vulnerableCallable = vulnerableCallables.get().stream()
                .filter(c -> methodName.equals(c.getMethodName()))
                .findFirst();
        if (vulnerableCallable.isEmpty()) {
            log.warning(String.format("Type %s is present in the vulnerability holder, but method %s is not", typeName, fastenMethodName));
            return;
        }

        addVulnerabilityEventsToSpan(vulnerableCallable.get());

        log.info("end of advice");
    }

    private static void addVulnerabilityEventsToSpan(VulnerableCallable callable) {
        for (var vulnerabilityId : callable.getVulnerabilityIds()) {
            var attributes = Attributes.builder()
                    .put(AttributeKey.stringKey("id"), callable.getId())
                    .put(AttributeKey.stringKey("severity"), callable.getSeverity().toString())
                    .put(AttributeKey.stringKey("method"), callable.getMethodName())
                    .put(AttributeKey.stringKey("package"), callable.getPackageName())
                    .put(AttributeKey.stringKey("class"), callable.getClassName())
                    .put(AttributeKey.stringKey("externalId"), vulnerabilityId)
                    .build();

            log.info(String.format("Added vulnerability trigger event (external ID: %s)", vulnerabilityId));
            Span.current().addEvent(EVENT_NAME, attributes);
        }
    }

}
