package nl.tudelft.kponichtera.thesis.vulnerabilitytracer.instrumentation;

import io.opentelemetry.javaagent.extension.instrumentation.TypeInstrumentation;
import io.opentelemetry.javaagent.extension.instrumentation.TypeTransformer;
import io.opentelemetry.javaagent.extension.matcher.AgentElementMatchers;
import lombok.extern.java.Log;
import net.bytebuddy.description.type.TypeDescription;
import net.bytebuddy.matcher.ElementMatcher;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.dto.VulnerableCallable;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.utils.TransformerUtils;

import java.util.List;

import static net.bytebuddy.matcher.ElementMatchers.named;

@Log
public class VulnerabilityTracerInstrumentation implements TypeInstrumentation {

    private final String className;
    private final List<VulnerableCallable> callables;

    public VulnerabilityTracerInstrumentation(String className, List<VulnerableCallable> callables) {
        this.className = className;
        this.callables = callables;
    }

    @Override
    public ElementMatcher<TypeDescription> typeMatcher() {
        // TODO: Potentially extend to instrumenting interfaces and abstract classes (callable defined = false in FASTEN API?)

        // Uncomment below one to make instrumentation work also with interfaces and abstract classes
//        return named(className).or(hasSuperType(named(className)));
        return named(className);
    }

    /**
     * Check if classes to be instrumented even exist (to avoid wasting resources on false positives).
     *
     * @return
     */
    @Override
    public ElementMatcher<ClassLoader> classLoaderOptimization() {
        return AgentElementMatchers.hasClassesNamed(className);
    }

    /**
     * Applies advice to every method from the vulnerable library packages.
     *
     * @param transformer
     */
    @Override
    public void transform(TypeTransformer transformer) {
        for (var callable : callables) {
            applyTraceExtenderAdvice(transformer, callable);
            switch (callable.getMitigationStrategy()) {
                case ERROR:
                    applyErrorTransform(transformer, callable);
                    break;
                case NOOP:
                    applyNoopTransform(transformer, callable);
                    break;
            }
        }
    }

    private void applyTraceExtenderAdvice(TypeTransformer transformer, VulnerableCallable callable) {
        transformer.applyAdviceToMethod(
                named(callable.getMethodName()),
                "nl.tudelft.kponichtera.thesis.vulnerabilitytracer.instrumentation.advice.TraceExtenderAdvice"
        );
        log.info(String.format("Applied trace extender advice to method %s in class %s.%s", callable.getMethodName(), callable.getPackageName(), callable.getClassName()));
    }


    private void applyErrorTransform(TypeTransformer transformer, VulnerableCallable callable) {
        TransformerUtils.applyErrorTransformer(transformer, callable);
        log.info(String.format("Applied error mitigation to method %s in class %s.%s", callable.getMethodName(), callable.getPackageName(), callable.getClassName()));
    }

    private void applyNoopTransform(TypeTransformer transformer, VulnerableCallable callable) {
        TransformerUtils.applyNoopTransformer(transformer, callable);
        log.info(String.format("Applied no-op mitigation to method %s in class %s.%s", callable.getMethodName(), callable.getPackageName(), callable.getClassName()));
    }

}
