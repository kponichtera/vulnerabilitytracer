package nl.tudelft.kponichtera.thesis.vulnerabilitytracer.utils;

import io.opentelemetry.api.common.AttributeKey;
import io.opentelemetry.api.common.Attributes;
import io.opentelemetry.api.trace.Span;
import io.opentelemetry.context.Context;
import io.opentelemetry.context.Scope;
import lombok.experimental.UtilityClass;
import lombok.extern.java.Log;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.exception.VulnerabilityHolderException;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.helper.VulnerabilityHolder;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.helper.VulnerabilityHolderHelper;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.dto.VulnerableCallable;

import java.io.IOException;

@Log
@UtilityClass
public class AdviceUtils {

    private static final String EVENT_NAME = "vulnerability-triggered";

    // TODO: Full method signature not taken into account, the first one is taken.
    //  Extend the search to compare parameter types as well
    public static VulnerableCallable getCallableMetadata(String methodName, String typeName) throws VulnerabilityHolderException {
        VulnerabilityHolder vulnerabilityHolder;
        try {
            vulnerabilityHolder = VulnerabilityHolderHelper.getStaticHolder();
        } catch (IOException e) {
            throw new VulnerabilityHolderException("Vulnerability holder could not be obtained", e);
        }

        var vulnerableCallables = vulnerabilityHolder.getCallablesForType(typeName);
        if (vulnerableCallables.isEmpty()) {
            throw new VulnerabilityHolderException(String.format("No type %s in vulnerability holder", typeName));
        }

        // Map method name, returned by OpenTelemetry, to the FASTEN format,
        // before searching for the method in the vulnerability holder
        var fastenMethodName = ReportUtils.fromOpentelemetryToFastenMethodName(typeName, methodName);

        var vulnerableCallable = vulnerableCallables.get().stream()
                .filter(c -> methodName.equals(c.getMethodName()))
                .findFirst();
        if (vulnerableCallable.isEmpty()) {
            throw new VulnerabilityHolderException(String.format("Type %s is present in the vulnerability holder, but method %s is not", typeName, fastenMethodName));
        }

        return vulnerableCallable.get();
    }

    public static void addEventsToSpan(VulnerableCallable callable) {
        for (var vulnerabilityId : callable.getVulnerabilityIds()) {
            var attributes = Attributes.builder()
                    .put(AttributeKey.stringKey("fastenId"), callable.getMethodName())
                    .put(AttributeKey.stringKey("method"), callable.getMethodName())
                    .put(AttributeKey.stringKey("package"), callable.getPackageName())
                    .put(AttributeKey.stringKey("class"), callable.getClassName())
                    .put(AttributeKey.stringKey("severity"), callable.getSeverity().toString())
                    .put(AttributeKey.stringKey("externalId"), vulnerabilityId)
                    .put(AttributeKey.stringKey("mitigationStrategy"), callable.getMitigationStrategy().toString())
                    .build();

            log.info(String.format("Added vulnerability trigger event (external ID: %s)", vulnerabilityId));
            Span.current().addEvent(EVENT_NAME, attributes);
        }
    }

}
