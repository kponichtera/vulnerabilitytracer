package nl.tudelft.kponichtera.thesis.vulnerabilitytracer.service;

import com.fasterxml.jackson.databind.JavaType;
import lombok.SneakyThrows;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.api.DefaultApi;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.api.invoker.ApiClient;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.api.invoker.ApiException;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.api.model.*;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.config.VulnerabilityTracerAgentConfig;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.dto.VulnerableCallable;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.enums.MitigationStrategy;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.enums.Severity;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.exception.CoordinatorApiException;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.report.MavenCoordinates;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

public class VulnerabilityCoordinatorService {

    private final DefaultApi coordinatorApi;

    public VulnerabilityCoordinatorService() {
        var apiClient = new ApiClient();
        apiClient.setBasePath(VulnerabilityTracerAgentConfig.getCoordinatorAddress());
        coordinatorApi = new DefaultApi(apiClient);
    }

    public List<VulnerableCallable> registerService(String serviceName, List<MavenCoordinates> dependencies) throws CoordinatorApiException {
        var request = new RegisterRequestPayload();
        request.setServiceName(serviceName);

        var apiDependencies = dependencies.stream()
                .map(VulnerabilityCoordinatorService::toApiMavenCoordinates)
                .collect(Collectors.toList());
        request.setDependencies(apiDependencies);

        RegisterResponsePayload response;
        try {
            response = coordinatorApi.register(request);
        } catch (ApiException e) {
            throw new CoordinatorApiException("Failed to register service", e);
        }

        if (response.getCallables() == null) {
            return List.of();
        }

        return response.getCallables().stream()
                .map(VulnerabilityCoordinatorService::toVulnerableCallable)
                .collect(Collectors.toList());
    }

    private static nl.tudelft.kponichtera.thesis.vulnerabilitytracer.api.model.MavenCoordinates toApiMavenCoordinates(MavenCoordinates reportDependency) {
        var apiMavenCoordinates = new nl.tudelft.kponichtera.thesis.vulnerabilitytracer.api.model.MavenCoordinates();
        apiMavenCoordinates.setGroupId(reportDependency.getGroupId());
        apiMavenCoordinates.setArtifactId(reportDependency.getArtifactId());
        apiMavenCoordinates.setVersion(reportDependency.getVersion());
        return apiMavenCoordinates;
    }

    private static VulnerableCallable toVulnerableCallable(JavaCallable javaCallable) {
        var vulnerableCallable = new VulnerableCallable();
        vulnerableCallable.setFastenId(javaCallable.getFastenId());
        vulnerableCallable.setClassName(javaCallable.getClassName());
        vulnerableCallable.setMethodName(javaCallable.getMethodName());
        vulnerableCallable.setPackageName(javaCallable.getPackageName());
        vulnerableCallable.setMitigationStrategy(toMitigationStrategy(javaCallable.getMitigationStrategy()));

        var vulnerabilityIds = javaCallable.getVulnerabilities().stream()
                .map(VulnerabilityMetadata::getExternalId)
                .collect(Collectors.toSet());

        var severity = javaCallable.getVulnerabilities().stream()
                .map(VulnerabilityMetadata::getSeverity)
                .map(VulnerabilityCoordinatorService::toSeverity)
                .max(Severity::compareTo)
                .orElse(Severity.UNDEFINED);

        vulnerableCallable.setVulnerabilityIds(vulnerabilityIds);
        vulnerableCallable.setSeverity(severity);
        return vulnerableCallable;
    }

    private static Severity toSeverity(VulnerabilitySeverity apiSeverity) {
        switch (apiSeverity) {
            case CRITICAL:
                return Severity.CRITICAL;
            case HIGH:
                return Severity.HIGH;
            case MEDIUM:
                return Severity.MEDIUM;
            case LOW:
                return Severity.LOW;
            default:
                return Severity.UNDEFINED;
        }
    }

    private static MitigationStrategy toMitigationStrategy(nl.tudelft.kponichtera.thesis.vulnerabilitytracer.api.model.MitigationStrategy apiMitigationStrategy) {
        switch (apiMitigationStrategy) {
            case NOOP:
                return MitigationStrategy.NOOP;
            case ERROR:
                return MitigationStrategy.ERROR;
            default:
                return MitigationStrategy.NONE;
        }
    }

}
