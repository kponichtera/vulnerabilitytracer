package nl.tudelft.kponichtera.thesis.vulnerabilitytracer.utils;

import lombok.experimental.UtilityClass;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.dto.VulnerableCallable;

import java.util.*;

@UtilityClass
public class ReportUtils {

    public static Map<String, List<VulnerableCallable>> extractCallablesForClasses(Collection<VulnerableCallable> callables) {
        var result = new HashMap<String, List<VulnerableCallable>>();
        for (var callable : callables) {
            var key = buildFullClassName(callable);
            result.putIfAbsent(key, new ArrayList<>());
            result.get(key).add(callable);
        }
        return result;
    }

    /**
     * Converts OpenTelemetry and ByteBuddy format of method naming to the one, found in FASTEN API responses.
     * <p>
     * For example, constructor name placeholder is replaced by the class short name.
     *
     * @param className  Full name of the class
     * @param methodName Name of the method
     * @return Name of the method in FASTEN format
     */
    public static String fromOpentelemetryToFastenMethodName(String className, String methodName) {
        if ("<init>".equals(methodName)) {
            return className.substring(className.lastIndexOf(".") + 1);
        }
        return methodName;
    }

    public static boolean isConstructor(String className, String methodName) {
        String classSimpleName;
        var classSimpleNameSeparator = className.lastIndexOf(".");
        if (classSimpleNameSeparator < 0) {
            classSimpleName = className;
        } else {
            classSimpleName = className.substring(className.lastIndexOf(".") + 1);
        }
        return methodName.equals(classSimpleName);
    }

    public static String buildFullClassName(VulnerableCallable callable) {
        return String.format("%s.%s", callable.getPackageName(), callable.getClassName());
    }


}
