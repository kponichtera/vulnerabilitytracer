package nl.tudelft.kponichtera.thesis.vulnerabilitytracer.helper;

import lombok.experimental.UtilityClass;
import lombok.extern.java.Log;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.exception.MissingReportException;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.utils.ReportLoaderUtils;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.utils.ReportUtils;

import java.io.IOException;

@Log
@UtilityClass
public class VulnerabilityHolderHelper {

    private static VulnerabilityHolder staticCallablesHolder;

    public static VulnerabilityHolder getStaticHolder() throws IOException {
        if (staticCallablesHolder != null) return staticCallablesHolder;
        log.info("Initializing static callables holder");
        staticCallablesHolder = buildHolder();
        return staticCallablesHolder;
    }

    public static VulnerabilityHolder buildHolder() throws IOException {
        var report = ReportLoaderUtils.loadReport();
        if (report.isEmpty()) {
            throw new MissingReportException("Dependency report not found");
        }

        // TODO: Implement fetching callables from vulnerability coordinator (ideally from instrumentation initialization)
        //  Or by creating a temporary file in the intrumentation init and reading it here
        throw new RuntimeException("TODO: Implement fetching callables from vulnerability coordinator");
//        var holderMap = ReportUtils.extractCallablesForClasses(report.get().getCallables());
//        return new VulnerabilityHolder(holderMap);
    }

}
