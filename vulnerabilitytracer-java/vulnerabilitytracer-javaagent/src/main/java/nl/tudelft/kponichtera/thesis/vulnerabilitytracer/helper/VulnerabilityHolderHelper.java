package nl.tudelft.kponichtera.thesis.vulnerabilitytracer.helper;

import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.experimental.UtilityClass;
import lombok.extern.java.Log;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.dto.VulnerableCallable;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.exception.VulnerabilityHolderNotInitializedException;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.exception.VulnerabilityHolderNotSavedException;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.utils.ReportUtils;

import java.io.File;
import java.io.IOException;
import java.util.List;

@Log
@UtilityClass
public class VulnerabilityHolderHelper {

    private static final String VULNERABILITY_HOLDER_FILENAME = "vulnerabilitytracer-vulnerabilities.json";
    private static final ObjectMapper VULNERABILITY_HOLDER_MAPPER = new ObjectMapper();

    private static VulnerabilityHolder staticCallablesHolder;

    public static VulnerabilityHolder getStaticHolder() throws IOException {
        if (staticCallablesHolder == null) {
            loadFromFile();
        }
        return staticCallablesHolder;
    }

    public static void initializeAndSave(List<VulnerableCallable> callables) throws IOException {
        initialize(callables);
        saveToFile();
    }

    public static void initialize(List<VulnerableCallable> callables) {
        var callableMappings = ReportUtils.extractCallablesForClasses(callables);
        staticCallablesHolder = new VulnerabilityHolder(callableMappings);
        log.info("Vulnerability holder initialized");
    }

    /**
     * Saves vulnerability holder to the file, so that it can be used in the instrumentation advices.
     */
    public static void saveToFile() throws IOException {
        if (staticCallablesHolder == null) {
            throw new VulnerabilityHolderNotInitializedException();
        }
        VULNERABILITY_HOLDER_MAPPER.writerWithDefaultPrettyPrinter().writeValue(new File(VULNERABILITY_HOLDER_FILENAME), staticCallablesHolder);
        log.info(String.format("Saved vulnerability holder to file %s", VULNERABILITY_HOLDER_FILENAME));
    }

    public static void loadFromFile() throws IOException {
        var file = new File(VULNERABILITY_HOLDER_FILENAME);
        if (!file.exists()) {
            throw new VulnerabilityHolderNotSavedException(VULNERABILITY_HOLDER_FILENAME);
        }

        staticCallablesHolder = VULNERABILITY_HOLDER_MAPPER.readValue(file, VulnerabilityHolder.class);
        log.info(String.format("Loaded vulnerability holder to file %s", VULNERABILITY_HOLDER_FILENAME));
    }

}
