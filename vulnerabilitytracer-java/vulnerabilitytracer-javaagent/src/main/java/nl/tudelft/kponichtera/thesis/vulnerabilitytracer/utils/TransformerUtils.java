package nl.tudelft.kponichtera.thesis.vulnerabilitytracer.utils;

import io.opentelemetry.javaagent.extension.instrumentation.TypeTransformer;
import lombok.experimental.UtilityClass;
import lombok.extern.java.Log;
import net.bytebuddy.implementation.ExceptionMethod;
import net.bytebuddy.implementation.FixedValue;
import net.bytebuddy.implementation.Implementation;
import net.bytebuddy.implementation.bytecode.constant.NullConstant;
import net.bytebuddy.implementation.bytecode.member.MethodReturn;
import net.bytebuddy.matcher.ElementMatchers;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.dto.VulnerableCallable;
import nl.tudelft.kponichtera.thesis.vulnerabilitytracer.exception.ErrorMitigationException;

import static net.bytebuddy.matcher.ElementMatchers.named;

@Log
@UtilityClass
public class TransformerUtils {

    public void applyErrorTransformer(TypeTransformer transformer, VulnerableCallable callable) {
        transformer.applyTransformer((builder, typeDescription, classLoader, module, protectionDomain) -> builder
                .method(named(callable.getMethodName()))
                .intercept(ExceptionMethod.throwing(ErrorMitigationException.class)));
    }

    public void applyNoopTransformer(TypeTransformer transformer, VulnerableCallable callable) {
        // Void
        transformer.applyTransformer((builder, typeDescription, classLoader, module, protectionDomain) -> builder
                .method(ElementMatchers.named(callable.getMethodName()).and(ElementMatchers.returns(void.class)))
                .intercept(new Implementation.Simple(NullConstant.INSTANCE, MethodReturn.VOID)));

        // Objects
        transformer.applyTransformer((builder, typeDescription, classLoader, module, protectionDomain) -> builder
                .method(ElementMatchers.named(callable.getMethodName()).and(ElementMatchers.returns(ElementMatchers.isSubTypeOf(Object.class))))
                .intercept(FixedValue.nullValue()));

        // Primitives
        transformer.applyTransformer((builder, typeDescription, classLoader, module, protectionDomain) -> builder
                .method(ElementMatchers.named(callable.getMethodName()).and(ElementMatchers.returns(byte.class)))
                .intercept(FixedValue.value((byte) 0)));
        transformer.applyTransformer((builder, typeDescription, classLoader, module, protectionDomain) -> builder
                .method(ElementMatchers.named(callable.getMethodName()).and(ElementMatchers.returns(short.class)))
                .intercept(FixedValue.value((short) 0)));
        transformer.applyTransformer((builder, typeDescription, classLoader, module, protectionDomain) -> builder
                .method(ElementMatchers.named(callable.getMethodName()).and(ElementMatchers.returns(int.class)))
                .intercept(FixedValue.value(0)));
        transformer.applyTransformer((builder, typeDescription, classLoader, module, protectionDomain) -> builder
                .method(ElementMatchers.named(callable.getMethodName()).and(ElementMatchers.returns(long.class)))
                .intercept(FixedValue.value((long) 0)));
        transformer.applyTransformer((builder, typeDescription, classLoader, module, protectionDomain) -> builder
                .method(ElementMatchers.named(callable.getMethodName()).and(ElementMatchers.returns(float.class)))
                .intercept(FixedValue.value((float) 0)));
        transformer.applyTransformer((builder, typeDescription, classLoader, module, protectionDomain) -> builder
                .method(ElementMatchers.named(callable.getMethodName()).and(ElementMatchers.returns(double.class)))
                .intercept(FixedValue.value((double) 0)));
        transformer.applyTransformer((builder, typeDescription, classLoader, module, protectionDomain) -> builder
                .method(ElementMatchers.named(callable.getMethodName()).and(ElementMatchers.returns(char.class)))
                .intercept(FixedValue.value(Character.MIN_VALUE)));
        transformer.applyTransformer((builder, typeDescription, classLoader, module, protectionDomain) -> builder
                .method(ElementMatchers.named(callable.getMethodName()).and(ElementMatchers.returns(boolean.class)))
                .intercept(FixedValue.value(false)));
    }

}
